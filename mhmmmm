local Module = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local.folder = workspace:WaitForChild("Humanoids")

local OrgDestroyHeight = workspace.FallenPartsDestroyHeight
local antivoidloop = nil
local antivoidWasEnabled = false
local swimming = false
local oldgrav = workspace.Gravity
local swimbeat = nil
local gravReset = nil
local noclipConnection = nil
local isSwimmingToDestination = false
local swimDestination = Vector3.new(0, 0, 0)
local swimSpeed = 100
local processedPrompts = {}
local amberCollectionEnabled = false
local currentAmberTarget = nil
local isCollecting = false
local amberCollectionCoroutine = nil

local bossTeleportEnabled = false
local currentBossTarget = nil
local bossBehindDistance = 5
local bossTeleportConnection = nil

local antivoidEnabled = false
local voidDetectionLoop = nil
local floatingEnabled = false
local floatPart = nil
local floatName = "AmberFarmFloat_" .. math.random(1000, 9999)
local amberPausedForVoid = false
local staffwatchjoin = nil
local staffwatchEnabled = false
local antiAfkEnabled = false
local antiAfkConnections = {}
local lastCollectionTime = tick()
local collectionTimeout = 30
local noclipEnabled = false

local knockbackFlyEnabled = false
local knockbackFlyConnection = nil
local knockbackMoveVec = Vector3.zero
local knockbackSpeed = 8
local knockbackReturnPosition = Vector3.new(129.97, 470.59, 235.64)
local knockbackReturningToBase = false
local knockbackInputConnections = {}

local AUTO_SPAWN_ENABLED = false
local SPAWN_ARGS = { [1] = "Gallimimus" }
local selectedDino = "Gallimimus"

local allDinosaurs = {
    "Acrocanthosaurus", "Albertosaurus", "Allosaurus", "Ankylosaurus", "Apatosaurus",
    "Baryonyx", "Brachiosaurus", "Carnotaurus", "Carcharodontosaurus", "Ceratosaurus",
    "Compsognathus", "Deinonychus", "Dilophosaurus", "Diplodocus", "Dreadnoughtus",
    "Gallimimus", "Giganotosaurus", "Invictus rex", "Mamenchisaurus", "Pachycephalosaurus",
    "Parasaurolophus", "Spinosaurus", "Stegosaurus", "Suchomimus", "Therizinosaurus",
    "Triceratops", "Tyrannosaurus", "Velociraptor", "Yutyrannus"
}

local lastVisibleGuis = {}
local SPAWN_COOLDOWN = 5
local lastSpawnTime = 0
local isSpawning = false

local espEnabled = false
local highlightEnabled = false
local teleporting = false
local npcTeleportEnabled = false
local currentTarget = nil
local currentNPCTarget = nil
local playerIndex = 1
local targetMovingPlayers = true
local targetStillPlayers = true
local behindDistance = 5
local npcBehindDistance = 5
local walkspeedEnabled = false
local customWalkspeed = 16
local HumanModCons = {}
local activeESPElements = {}
local activeHighlights = {}
local npcTeleportConnection = nil
local Connections = {}

local amberAttemptStartTime = 0
local amberAttemptTimeout = 15
local lastPlayerPosition = Vector3.new(0, 0, 0)
local stuckCheckCounter = 0
local stuckThreshold = 30
local v2SwitchedToV1 = false

local autoAttackEnabled = false
local autoHeavyEnabled = false
local autoAttackConnection = nil
local autoHeavyConnection = nil

function Module.executeAutoAttack()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local requestSkill = ReplicatedStorage["@rbxts/wcs:source/networking@GlobalEvents"].requestSkill
        requestSkill:FireServer({
            blobs = {0.5600000024, workspace:GetServerTimeNow(), false},
            buffer = buffer.fromstring("\8\0\0\0M1Attack\1\3\0\0\0\1\1\1")
        })
    end)
end

function Module.executeAutoHeavy()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local onHeavyRequest = ReplicatedStorage["shared/network/init@GlobalEvents"].onHeavyRequest
        onHeavyRequest:FireServer()
    end)
end

function Module.executeInstantDespawn()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local despawn = ReplicatedStorage["shared/network/init@GlobalEvents"].despawn
        despawn:FireServer()
    end)
end

function Module.toggleAutoAttack(value)
    autoAttackEnabled = value
    if value then
        if autoAttackConnection then
            autoAttackConnection:Disconnect()
        end
        autoAttackConnection = RunService.Heartbeat:Connect(function()
            if autoAttackEnabled then
                Module.executeAutoAttack()
            end
        end)
        Connections.autoAttack = autoAttackConnection
    else
        if autoAttackConnection then
            autoAttackConnection:Disconnect()
            autoAttackConnection = nil
            Connections.autoAttack = nil
        end
    end
end

function Module.toggleAutoHeavy(value)
    autoHeavyEnabled = value
    if value then
        if autoHeavyConnection then
            autoHeavyConnection:Disconnect()
        end
        autoHeavyConnection = RunService.Heartbeat:Connect(function()
            if autoHeavyEnabled then
                Module.executeAutoHeavy()
            end
        end)
        Connections.autoHeavy = autoHeavyConnection
    else
        if autoHeavyConnection then
            autoHeavyConnection:Disconnect()
            autoHeavyConnection = nil
            Connections.autoHeavy = nil
        end
    end
end

function Module.getRoot(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
end

function Module.enableAntiVoid()
    if antivoidloop then
        antivoidloop:Disconnect()
        antivoidloop = nil
    end
    antivoidloop = RunService.Stepped:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if root and root.Position.Y <= OrgDestroyHeight + 25 then
            root.Velocity = root.Velocity + Vector3.new(0, 250, 0)
        end
    end)
    Connections.antivoid = antivoidloop
    antivoidEnabled = true
end

function Module.disableAntiVoid()
    if antivoidloop then
        antivoidloop:Disconnect()
        antivoidloop = nil
        Connections.antivoid = nil
    end
    antivoidEnabled = false
end

function Module.fakeOut()
    local root = Module.getRoot(localPlayer.Character)
    if not root then return end
    local oldpos = root.CFrame
    if antivoidloop then
        Module.disableAntiVoid()
        antivoidWasEnabled = true
    end
    workspace.FallenPartsDestroyHeight = math.huge
    root.CFrame = CFrame.new(Vector3.new(0, OrgDestroyHeight - 25, 0))
    task.wait(1)
    root.CFrame = oldpos
    workspace.FallenPartsDestroyHeight = OrgDestroyHeight
    if antivoidWasEnabled then
        Module.enableAntiVoid()
        antivoidWasEnabled = false
    end
end

function Module.executeSpawn()
    local currentTime = tick()
    if currentTime - lastSpawnTime < SPAWN_COOLDOWN then
        return false
    end
    if isSpawning then
        return false
    end
    isSpawning = true
    lastSpawnTime = currentTime
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("shared/network/init@GlobalEvents", 9e9):WaitForChild("spawn", 9e9):FireServer(unpack(SPAWN_ARGS))
    end)
    isSpawning = false
    return true
end

function Module.getFullPath(obj)
    local path = obj.Name
    local parent = obj.Parent
    while parent and parent ~= game do
        path = parent.Name .. "." .. path
        parent = parent.Parent
    end
    return path
end

function Module.checkForNewAppGuis(currentGuis)
    local newAppGuis = {}
    for path, _ in pairs(currentGuis) do
        if not lastVisibleGuis[path] and string.find(string.lower(path), "playergui%.app") ~= nil then
            table.insert(newAppGuis, path)
        end
    end
    return newAppGuis
end

function Module.scanForVisibleGuis()
    if not AUTO_SPAWN_ENABLED then return end
    local currentGuis = {}
    local function scanGui(obj)
        if obj:IsA("GuiObject") and obj.Visible then
            local fullPath = Module.getFullPath(obj)
            currentGuis[fullPath] = true
        end
        for _, sub in ipairs(obj:GetChildren()) do
            scanGui(sub)
        end
    end
    pcall(function()
        scanGui(localPlayer:WaitForChild("PlayerGui"))
    end)
    local newAppGuis = Module.checkForNewAppGuis(currentGuis)
    if #newAppGuis > 0 then
        Module.executeSpawn()
    end
    lastVisibleGuis = currentGuis
end

function Module.isAboveTerrain(position)
    local region = Region3.new(
        Vector3.new(position.X - 1, position.Y - 200, position.Z - 1),
        Vector3.new(position.X + 1, position.Y, position.Z + 1)
    )
    local terrainRegion = Workspace.Terrain:ReadVoxels(region, 4)
    local size = terrainRegion.Size
    for x = 1, size.X do
        for y = 1, size.Y do
            for z = 1, size.Z do
                if terrainRegion:get(x, y, z).Value > 0 then
                    return true
                end
            end
        end
    end
    return false
end

function Module.hasGroundBelow(position, maxDistance)
    maxDistance = maxDistance or 50
    if Module.isAboveTerrain(position) then
        return true
    end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {localPlayer.Character}
    local raycastResult = Workspace:Raycast(position, Vector3.new(0, -maxDistance, 0), raycastParams)
    return raycastResult ~= nil
end

function Module.enableFloating()
    if floatingEnabled or not localPlayer.Character then return end
    local pchar = localPlayer.Character
    local root = Module.getRoot(pchar)
    if not root then return end
    floatingEnabled = true
    floatPart = Instance.new('Part')
    floatPart.Name = floatName
    floatPart.Parent = pchar
    floatPart.Transparency = 1
    floatPart.Size = Vector3.new(2, 0.2, 1.5)
    floatPart.Anchored = true
    floatPart.CFrame = root.CFrame * CFrame.new(0, -3.1, 0)
    local floatConnection
    floatConnection = RunService.Heartbeat:Connect(function()
        if floatingEnabled and pchar:FindFirstChild(floatName) and Module.getRoot(pchar) then
            floatPart.CFrame = Module.getRoot(pchar).CFrame * CFrame.new(0, -3.1, 0)
        else
            if floatConnection then
                floatConnection:Disconnect()
            end
        end
    end)
end

function Module.disableFloating()
    if not floatingEnabled then return end
    floatingEnabled = false
    if floatPart then
        floatPart:Destroy()
        floatPart = nil
    end
    local pchar = localPlayer.Character
    if pchar and pchar:FindFirstChild(floatName) then
        pchar:FindFirstChild(floatName):Destroy()
    end
end

function Module.startVoidDetection()
    if voidDetectionLoop then
        voidDetectionLoop:Disconnect()
    end
    voidDetectionLoop = RunService.Heartbeat:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if not root then return end
        local position = root.Position
        local hasGround = Module.hasGroundBelow(position, 100)
        if not hasGround then
            if amberCollectionEnabled and not amberPausedForVoid then
                amberPausedForVoid = true
            end
            if not floatingEnabled then
                Module.enableFloating()
            end
        else
            if amberPausedForVoid then
                amberPausedForVoid = false
            end
            if floatingEnabled then
                Module.disableFloating()
            end
        end
    end)
end

function Module.stopVoidDetection()
    if voidDetectionLoop then
        voidDetectionLoop:Disconnect()
        voidDetectionLoop = nil
    end
    Module.disableFloating()
    amberPausedForVoid = false
end

function Module.getStaffRole(player)
    if game.CreatorType == Enum.CreatorType.Group then
        local groupId = game.CreatorId
        local success, role = pcall(function()
            return player:GetRoleInGroup(groupId)
        end)
        if success and role then
            local staffRoles = {"Owner", "Co-Owner", "Admin", "Administrator", "Moderator", "Mod", "Staff", "Developer", "Dev"}
            for _, staffRole in pairs(staffRoles) do
                if string.find(string.lower(role), string.lower(staffRole)) then
                    return {Staff = true, Role = role}
                end
            end
        end
    end
    return {Staff = false, Role = "Member"}
end

function Module.toggleStaffWatch(value)
    staffwatchEnabled = value
    if value then
        if staffwatchjoin then
            staffwatchjoin:Disconnect()
        end
        if game.CreatorType == Enum.CreatorType.Group then
            staffwatchjoin = Players.PlayerAdded:Connect(function(player)
                local result = Module.getStaffRole(player)
            end)
            for _, player in pairs(Players:GetPlayers()) do
                local result = Module.getStaffRole(player)
                if result.Staff then
                    print("@" .. player.Name .. " is a " .. result.Role)
                end
            end
        end
    else
        if staffwatchjoin then
            staffwatchjoin:Disconnect()
            staffwatchjoin = nil
        end
    end
end

function Module.enableAntiAfk()
    if antiAfkEnabled then return end
    antiAfkEnabled = true
    antiAfkConnections.virtualUser = game:GetService("UserInputService").InputBegan:Connect(function() end)
    antiAfkConnections.periodicInput = task.spawn(function()
        while antiAfkEnabled do
            task.wait(300)
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end
    end)
    antiAfkConnections.characterMovement = task.spawn(function()
        while antiAfkEnabled do
            task.wait(600)
            local char = localPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local root = char.HumanoidRootPart
                local originalPos = root.CFrame
                root.CFrame = originalPos + Vector3.new(0.1, 0, 0)
                task.wait(0.1)
                root.CFrame = originalPos
            end
        end
    end)
    antiAfkConnections.idleConnection = localPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

function Module.disableAntiAfk()
    antiAfkEnabled = false
    for name, connection in pairs(antiAfkConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            else
                task.cancel(connection)
            end
        end
    end
    antiAfkConnections = {}
end

function Module.noclip()
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

function Module.enableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
    noclipConnection = RunService.Stepped:Connect(Module.noclip)
    Connections.noclip = noclipConnection
    noclipEnabled = true
end

function Module.disableNoclip()
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
        Connections.noclip = nil
    end
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    noclipEnabled = false
end

function Module.startSwim()
    if not swimming and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        oldgrav = workspace.Gravity
        workspace.Gravity = 0
        local swimDied = function()
            workspace.Gravity = oldgrav
            swimming = false
            Module.disableNoclip()
            Connections.swimDied = nil
        end
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        gravReset = Humanoid.Died:Connect(swimDied)
        Connections.swimDied = gravReset
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, false)
        end
        Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
        swimbeat = RunService.Heartbeat:Connect(function()
            pcall(function()
                local hrp = localPlayer.Character.HumanoidRootPart
                local humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                if isSwimmingToDestination then
                    local currentPos = hrp.Position
                    local direction = (swimDestination - currentPos).Unit
                    local distance = (swimDestination - currentPos).Magnitude
                    if distance < 5 then
                        isSwimmingToDestination = false
                        hrp.Velocity = Vector3.new(0, 0, 0)
                    else
                        hrp.Velocity = direction * swimSpeed
                    end
                else
                    local moveVector = humanoid.MoveDirection
                    local camera = workspace.CurrentCamera
                    local cameraCFrame = camera.CFrame
                    local worldMoveVector = Vector3.new(0, 0, 0)
                    if moveVector.Magnitude > 0 then
                        local cameraRight = cameraCFrame.RightVector
                        local cameraForward = -cameraCFrame.LookVector
                        cameraRight = Vector3.new(cameraRight.X, 0, cameraRight.Z).Unit
                        cameraForward = Vector3.new(cameraForward.X, 0, cameraForward.Z).Unit
                        worldMoveVector = (cameraRight * moveVector.X + cameraForward * moveVector.Z)
                    end
                    local verticalMovement = 0
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        verticalMovement = 1
                    elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        verticalMovement = -1
                    end
                    local finalMoveVector = Vector3.new(worldMoveVector.X, verticalMovement, worldMoveVector.Z)
                    if finalMoveVector.Magnitude > 0 then
                        hrp.Velocity = finalMoveVector.Unit * swimSpeed
                    else
                        hrp.Velocity = hrp.Velocity * 0.9
                    end
                end
            end)
        end)
        Connections.swimbeat = swimbeat
        Module.enableNoclip()
        swimming = true
        return true
    end
    return false
end

function Module.stopSwim()
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        workspace.Gravity = oldgrav
        swimming = false
        isSwimmingToDestination = false
        if gravReset then
            gravReset:Disconnect()
            gravReset = nil
            Connections.swimDied = nil
        end
        if swimbeat then
            swimbeat:Disconnect()
            swimbeat = nil
            Connections.swimbeat = nil
        end
        Module.disableNoclip()
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, true)
        end
    end
end

function Module.swimToDestination(targetPosition)
    local character = localPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local hrp = character.HumanoidRootPart
    local currentPos = hrp.Position
    local skyPosition = Vector3.new(currentPos.X, currentPos.Y + 100, currentPos.Z)
    hrp.CFrame = CFrame.new(skyPosition)
    isSwimmingToDestination = true
    swimDestination = targetPosition
    if not swimming then
        Module.startSwim()
    end
end

function Module.moveTowardsTarget(targetPosition, stepSize, speed)
    local char = localPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return false end
    local root = char.HumanoidRootPart
    if not targetPosition then return false end
    local currentPos = root.Position
    local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
    local direction = (targetPosAbove - currentPos).Unit
    local distance = (targetPosAbove - currentPos).Magnitude
    if distance <= 8 then
        return true
    end
    local moveDistance = math.min(stepSize or 40, distance * 0.6)
    local newPos = currentPos + (direction * moveDistance)
    if newPos.Y > currentPos.Y then
        newPos = newPos + Vector3.new(0, 5, 0)
    end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame.new(newPos, newPos + root.CFrame.LookVector)})
    tween.Completed:Connect(function()
        task.wait(0.05)
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end)
    tween:Play()
    tween.Completed:Wait()
    return false
end

function Module.getHumanoidRootPart(model)
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
end

function Module.isPlayerMoving(player)
    if not player or not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return false
    end
    return player.Character.Humanoid.MoveDirection.Magnitude > 0.1
end

function Module.isPlayerDead(player)
    return not player or not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0
end

function Module.setWalkspeed(speed)
    if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
        local Char = localPlayer.Character
        local Human = Char:FindFirstChildWhichIsA("Humanoid")
        local function WalkSpeedChange()
            if Char and Human and walkspeedEnabled then
                Human.WalkSpeed = speed
            end
        end
        WalkSpeedChange()
        HumanModCons.wsLoop = (HumanModCons.wsLoop and HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
        Connections.wsLoop = HumanModCons.wsLoop
        HumanModCons.wsCA = (HumanModCons.wsCA and HumanModCons.wsCA:Disconnect() and nil) or localPlayer.CharacterAdded:Connect(function(nChar)
            Char, Human = nChar, nChar:WaitForChild("Humanoid")
            character = nChar
            hrp = nChar:WaitForChild("HumanoidRootPart")
            WalkSpeedChange()
            HumanModCons.wsLoop = (HumanModCons.wsLoop and HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
            Connections.wsLoop = HumanModCons.wsLoop
        end)
        Connections.wsCA = HumanModCons.wsCA
    end
end

function Module.toggleWalkspeed(value)
    walkspeedEnabled = value
    if value then
        Module.setWalkspeed(customWalkspeed)
    else
        if HumanModCons.wsLoop then
            HumanModCons.wsLoop:Disconnect()
            HumanModCons.wsLoop = nil
            Connections.wsLoop = nil
        end
        if HumanModCons.wsCA then
            HumanModCons.wsCA:Disconnect()
            HumanModCons.wsCA = nil
            Connections.wsCA = nil
        end
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            localPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
end

function Module.updateWalkspeed(value)
    customWalkspeed = value
    if walkspeedEnabled then
        Module.setWalkspeed(customWalkspeed)
    end
end

function Module.applyESP(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_ESP") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    local root = Module.getHumanoidRootPart(model)
    if not root then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NPC_ESP"
    billboard.Adornee = root
    billboard.Size = UDim2.new(0, 80, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = model.Name
    label.TextColor3 = Color3.fromRGB(255, 0, 0)
    label.TextStrokeTransparency = 0
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = billboard
    billboard.Parent = root
    activeESPElements[model] = billboard
    local connection
    connection = humanoid.Died:Connect(function()
        billboard:Destroy()
        activeESPElements[model] = nil
        if connection then
            Connections["ESP_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Connections["ESP_" .. tostring(model)] = connection
end

function Module.applyHighlight(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_Highlight") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    if not humanoid then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "NPC_Highlight"
    highlight.Adornee = model
    highlight.FillColor = Color3.fromRGB(100, 150, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    activeHighlights[model] = highlight
    local connection
    connection = humanoid.Died:Connect(function()
        highlight:Destroy()
        activeHighlights[model] = nil
        if connection then
            Connections["Highlight_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Connections["Highlight_" .. tostring(model)] = connection
end

function Module.toggleESP(value)
    espEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyESP(model)
        end
    else
        for model, billboard in pairs(activeESPElements) do
            if billboard and billboard.Parent then
                billboard:Destroy()
            end
            if Connections["ESP_" .. tostring(model)] then
                Connections["ESP_" .. tostring(model)]:Disconnect()
                Connections["ESP_" .. tostring(model)] = nil
            end
        end
        activeESPElements = {}
    end
end

function Module.toggleHighlight(value)
    highlightEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyHighlight(model)
        end
    else
        for model, highlight in pairs(activeHighlights) do
            if highlight and highlight.Parent then
                highlight:Destroy()
            end
            if Connections["Highlight_" .. tostring(model)] then
                Connections["Highlight_" .. tostring(model)]:Disconnect()
                Connections["Highlight_" .. tostring(model)] = nil
            end
        end
        activeHighlights = {}
    end
end

function Module.getValidPlayers()
    local players = Players:GetPlayers()
    local validPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
           player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local isMoving = Module.isPlayerMoving(player)
            if (isMoving and targetMovingPlayers) or (not isMoving and targetStillPlayers) then
                table.insert(validPlayers, player)
            end
        end
    end
    return validPlayers
end

function Module.getNextTarget()
    local validPlayers = Module.getValidPlayers()
    if #validPlayers == 0 then
        return nil
    end
    playerIndex = ((playerIndex - 1) % #validPlayers) + 1
    return validPlayers[playerIndex]
end

function Module.anchorToPlayer(targetPlayer)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetPlayer.Character.HumanoidRootPart
    local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    local targetLookVector = targetRoot.CFrame.LookVector
    if targetHumanoid and targetHumanoid.MoveDirection.Magnitude > 0.1 then
        local moveDirection = targetHumanoid.MoveDirection
        targetLookVector = Vector3.new(moveDirection.X, 0, moveDirection.Z).Unit
    end
    local behindPosition = targetRoot.Position - (targetLookVector * behindDistance)
    behindPosition = Vector3.new(behindPosition.X, targetRoot.Position.Y, behindPosition.Z)
    local newCFrame = CFrame.lookAt(behindPosition, targetRoot.Position)
    localPlayer.Character.HumanoidRootPart.CFrame = newCFrame
    localPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.teleportLoop()
    if not teleporting then return end
    if not currentTarget or Module.isPlayerDead(currentTarget) then
        currentTarget = Module.getNextTarget()
        if currentTarget then
            Module.anchorToPlayer(currentTarget)
        else
            task.wait(1)
            return
        end
    end
    if localPlayer.Character and currentTarget.Character then
        local myPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = currentTarget.Character.HumanoidRootPart.Position
        local targetLookVector = currentTarget.Character.HumanoidRootPart.CFrame.LookVector
        local intendedPosition = targetPosition - (targetLookVector * behindDistance)
        local distanceFromIntended = (myPosition - intendedPosition).Magnitude
        if distanceFromIntended > 2 then
            Module.anchorToPlayer(currentTarget)
        end
    end
end

function Module.getClosestNPC()
    local closest = nil
    local shortestDist = math.huge
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortestDist then
                shortestDist = dist
                closest = npc
            end
        end
    end
    return closest
end

function Module.anchorToNPC(targetNPC)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetNPC:FindFirstChild("HumanoidRootPart")
    if not targetRoot then
        return false
    end
    local dir = -(targetRoot.CFrame.LookVector) * npcBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.npcTeleportLoop()
    if not npcTeleportEnabled then return end
    if not currentNPCTarget or not currentNPCTarget:IsDescendantOf(workspace) or currentNPCTarget.Humanoid.Health <= 0 then
        currentNPCTarget = Module.getClosestNPC()
        if not currentNPCTarget then
            return
        end
    end
    if hrp and currentNPCTarget.HumanoidRootPart then
        Module.anchorToNPC(currentNPCTarget)
    end
end

function Module.toggleNPCTeleport(value)
    npcTeleportEnabled = value
    if value then
        currentNPCTarget = Module.getClosestNPC()
        if currentNPCTarget then
            Module.anchorToNPC(currentNPCTarget)
        end
        npcTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.npcTeleportLoop()
        end)
        Connections.npcTeleport = npcTeleportConnection
    else
        currentNPCTarget = nil
        if npcTeleportConnection then
            npcTeleportConnection:Disconnect()
            npcTeleportConnection = nil
            Connections.npcTeleport = nil
        end
    end
end

function Module.switchToNextNPC()
    local allNPCs = {}
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            table.insert(allNPCs, npc)
        end
    end
    if #allNPCs == 0 then
        return nil
    elseif #allNPCs == 1 then
        return allNPCs[1]
    else
        for _, npc in pairs(allNPCs) do
            if npc ~= currentNPCTarget then
                return npc
            end
        end
        return allNPCs[1]
    end
end

function Module.deepSearchProximityPrompts(obj, path)
    local prompts = {}
    path = path or obj.Name
    if obj:IsA("ProximityPrompt") then
        table.insert(prompts, {prompt = obj, path = path, parent = obj.Parent})
        return prompts
    end
    for _, child in pairs(obj:GetChildren()) do
        local childPath = path .. "." .. child.Name
        local childPrompts = Module.deepSearchProximityPrompts(child, childPath)
        for _, promptData in pairs(childPrompts) do
            table.insert(prompts, promptData)
        end
    end
    return prompts
end

function Module.getBestPosition(obj)
    local function findPartPosition(searchObj)
        if searchObj:IsA("BasePart") then
            return searchObj.Position
        elseif searchObj:IsA("Model") and searchObj.PrimaryPart then
            return searchObj.PrimaryPart.Position
        else
            for _, child in pairs(searchObj:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        return nil
    end
    local pos = findPartPosition(obj)
    if pos then return pos end
    local current = obj.Parent
    while current and current ~= Workspace do
        pos = findPartPosition(current)
        if pos then return pos end
        current = current.Parent
    end
    return nil
end

function Module.getAllAmberPrompts()
    local itemSpawn = Workspace:FindFirstChild("ItemSpawn")
    if not itemSpawn then
        return {}
    end
    local amber = itemSpawn:FindFirstChild("Amber")
    if not amber then
        return {}
    end
    local allPrompts = {}
    for _, child in pairs(amber:GetChildren()) do
        if child.Name == "AmberSpawn" then
            local prompts = Module.deepSearchProximityPrompts(child)
            for _, promptData in pairs(prompts) do
                local promptId = tostring(promptData.prompt)
                if not processedPrompts[promptId] and promptData.prompt.Parent and promptData.prompt.Enabled then
                    table.insert(allPrompts, promptData)
                end
            end
        end
    end
    return allPrompts
end

function Module.fireProximityPromptSwim(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        processedPrompts[promptId] = true
        return false
    end
    if not swimming then
        Module.startSwim()
        task.wait(0.2)
    end
    Module.swimToDestination(targetPosition)
    local timeoutCounter = 0
    local maxTimeout = 50
    while isSwimmingToDestination and timeoutCounter < maxTimeout do
        task.wait(0.1)
        timeoutCounter = timeoutCounter + 1
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
    end
    if hrp and prompt.Parent and prompt.Enabled then
        local distance = (hrp.Position - targetPosition).Magnitude
        if distance < 20 then
            local success = false
            pcall(function()
                fireproximityprompt(prompt, 0, true)
                success = true
            end)
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt)
                    success = true
                end)
            end
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt, prompt.HoldDuration or 0)
                    success = true
                end)
            end
        end
    end
    processedPrompts[promptId] = true
    task.wait(0.1)
    return true
end

function Module.fireProximityPromptTween(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        processedPrompts[promptId] = true
        return false
    end
    amberAttemptStartTime = tick()
    local maxAttempts = 6
    local attempts = 0
    while attempts < maxAttempts and amberCollectionEnabled do
        attempts = attempts + 1
        if not prompt.Parent or not prompt.Enabled then
            processedPrompts[promptId] = true
            return false
        end
        if tick() - amberAttemptStartTime > amberAttemptTimeout then
            processedPrompts[promptId] = true
            return false
        end
        for _, part in pairs(localPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        local isCloseEnough = Module.moveTowardsTarget(targetPosition, 50, 5)
        task.wait(0.15)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
        if hrp and prompt.Parent and prompt.Enabled then
            local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
            local distance = (hrp.Position - targetPosAbove).Magnitude
            if distance < 30 then
                local success = false
                pcall(function()
                    fireproximityprompt(prompt, 0, true)
                    success = true
                end)
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt)
                        success = true
                    end)
                end
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt, prompt.HoldDuration or 0)
                        success = true
                    end)
                end
                if success then
                    lastCollectionTime = tick()
                end
                break
            end
        end
    end
    for _, part in pairs(localPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    processedPrompts[promptId] = true
    task.wait(0.05)
    return true
end

function Module.amberCollectionLoopSwim()
    if not amberCollectionEnabled or isCollecting then 
        return 
    end
    isCollecting = true
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptSwim(currentAmberTarget)
    else
        processedPrompts = {}
        currentAmberTarget = nil
        Module.stopSwim()
        task.wait(1)
    end
    isCollecting = false
end

function Module.amberCollectionLoopTween()
    if not amberCollectionEnabled then 
        return 
    end
    if amberPausedForVoid then
        return
    end
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        hrp = localPlayer.Character.HumanoidRootPart
        local currentPos = hrp.Position
        local distanceMoved = (currentPos - lastPlayerPosition).Magnitude
        if distanceMoved < 0.5 then
            stuckCheckCounter = stuckCheckCounter + 1
        else
            stuckCheckCounter = 0
        end
        lastPlayerPosition = currentPos
        if stuckCheckCounter > stuckThreshold and not v2SwitchedToV1 then
            v2SwitchedToV1 = true
            return
        end
    end
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptTween(currentAmberTarget)
    else
        currentAmberTarget = nil
        processedPrompts = {}
    end
end

function Module.toggleAmberCollectionSwim(value)
    amberCollectionEnabled = value
    if value then
        processedPrompts = {}
        currentAmberTarget = nil
        amberCollectionCoroutine = task.spawn(function()
            while amberCollectionEnabled do
                pcall(function()
                    Module.amberCollectionLoopSwim()
                end)
                task.wait(0.3)
            end
        end)
    else
        amberCollectionEnabled = false
        currentAmberTarget = nil
        isCollecting = false
        Module.stopSwim()
        if amberCollectionCoroutine then
            task.cancel(amberCollectionCoroutine)
            amberCollectionCoroutine = nil
        end
    end
end

function Module.toggleAmberCollection(value)
    amberCollectionEnabled = value
    if value then
        lastCollectionTime = tick()
        Module.enableAntiVoid()
        Module.startVoidDetection()
        processedPrompts = {}
        currentAmberTarget = nil
        v2SwitchedToV1 = false
        stuckCheckCounter = 0
        lastPlayerPosition = Vector3.new(0, 0, 0)
        amberCollectionCoroutine = task.spawn(function()
            while amberCollectionEnabled do
                pcall(function()
                    if v2SwitchedToV1 then
                        Module.amberCollectionLoopSwim()
                        if not swimming then
                            v2SwitchedToV1 = false
                            stuckCheckCounter = 0
                        end
                    else
                        Module.amberCollectionLoopTween()
                    end
                end)
                task.wait(0.05)
            end
        end)
    else
        amberCollectionEnabled = false
        currentAmberTarget = nil
        amberPausedForVoid = false
        v2SwitchedToV1 = false
        stuckCheckCounter = 0
        Module.stopVoidDetection()
        Module.disableAntiVoid()
        if amberCollectionCoroutine then
            task.cancel(amberCollectionCoroutine)
            amberCollectionCoroutine = nil
        end
    end
end

function Module.stabilizeCharacter()
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if currentHrp then
        currentHrp.RotVelocity = Vector3.zero
        currentHrp.AssemblyAngularVelocity = Vector3.zero
    end
end

function Module.applyKnockbackThrust()
    if not knockbackFlyEnabled then return end
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return end
    if knockbackMoveVec.Magnitude > 0 then
        local dir = workspace.CurrentCamera.CFrame:VectorToWorldSpace(knockbackMoveVec).Unit
        local thrust = dir * math.clamp(knockbackSpeed, 1, 20)
        thrust = Vector3.new(
            math.clamp(thrust.X, -10, 10),
            math.clamp(thrust.Y, -5, 5),
            math.clamp(thrust.Z, -10, 10)
        )
        pcall(function()
            local requestKnockback = game:GetService("ReplicatedStorage")["shared/network/init@GlobalEvents"].requestKnockback
            firesignal(requestKnockback.OnClientEvent, 15, 0.6, thrust)
        end)
    end
end

function Module.startKnockbackFly()
    knockbackFlyEnabled = true
    if knockbackFlyConnection then
        knockbackFlyConnection:Disconnect()
    end
    knockbackFlyConnection = RunService.Heartbeat:Connect(function()
        if knockback flyEnabled then
            Module.stabilizeCharacter()
            Module.applyKnockbackThrust()
        end
    end)
    Connections.knockbackFly = knockbackFlyConnection
end

function Module.stopKnockbackFly()
    knockbackFlyEnabled = false
    if knockbackFlyConnection then
        knockbackFlyConnection:Disconnect()
        knockbackFlyConnection = nil
        Connections.knockbackFly = nil
    end outward
end

function Module.moveToPositionKnockback(targetPosition)
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return false end
    local distance = (currentHrp.Position - targetPosition).Magnitude
    if distance < 10 then
        return true
    end
    local direction = (targetPosition - currentHrp.Position).Unit
    local thrust = direction * math.clamp(knockbackSpeed, 1, 20)
    thrust = Vector3.new(
        math.clamp(thrust.X, -10, 10),
        math.clamp(thrust.Y, -5, 5),
        math.clamp(thrust.Z, -10, 10)
    )
    pcall(function()
        local requestKnockback = game:GetService("ReplicatedStorage")["shared/network/init@GlobalEvents"].requestKnockback
        firesignal(requestKnockback.OnClientEvent, 15, 0.6, thrust)
    end)
    return false
end

function Module.moveToAmberKnockback(targetPosition)
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return false end
    local distance = (currentHrp.Position - targetPosition).Magnitude
    if distance < 20 then
        return true
    end
    local direction = (targetPosition - currentHrp.Position).Unit
    local thrust = direction * math.clamp(knockbackSpeed, 1, 20)
    thrust = Vector3.new(
        math.clamp(thrust.X, -10, 10),
        math.clamp(thrust.Y, -5, 5),
        math.clamp(thrust.Z, -10, 10)
    )
    pcall(function()
        local requestKnockback = game:GetService("ReplicatedStorage")["shared/network/init@GlobalEvents"].requestKnockback
        firesignal(requestKnockback.OnClientEvent, 15, 0.6, thrust)
    end)
    return false
end

function Module.amberCollectionLoopKnockback()
    if not amberCollectionEnabled then return end
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return end
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if not knockbackFlyEnabled then
            Module.startKnockbackFly()
        end
        knockbackReturningToBase = false
        table.sort(availablePrompts, function(a, b)
            local posA = Module.getBestPosition(a.prompt)
            local posB = Module.getBestPosition(b.prompt)
            if posA and posB then
                local distA = (currentHrp.Position - posA).Magnitude
                local distB = (currentHrp.Position - posB).Magnitude
                return distA < distB
            end
            return false
        end)
        currentAmberTarget = availablePrompts[1]
        local targetPos = Module.getBestPosition(currentAmberTarget.prompt)
        if targetPos then
            local isClose = Module.moveToAmberKnockback(targetPos)
            if isClose then
                local prompt = currentAmberTarget.prompt
                local promptId = tostring(prompt)
                if prompt.Parent and prompt.Enabled then
                    pcall(function()
                        fireproximityprompt(prompt, 0, true)
                    end)
                    task.wait(0.02)
                    if prompt.Parent and prompt.Enabled then
                        pcall(function()
                            fireproximityprompt(prompt)
                        end)
                    end
                    processedPrompts[promptId] = true
                end
            end
        end
    else
        processedPrompts = {}
        currentAmberTarget = nil
        if not knockbackReturningToBase then
            knockbackReturningToBase = true
        end
        if knockbackReturningToBase then
            local reachedBase = Module.moveToPositionKnockback(knockbackReturnPosition)
            if reachedBase then
                Module.stopKnockbackFly()
                knockbackReturningToBase = false
            end
        end
    end
end

function Module.setupKnockbackInput()
    knockbackInputConnections.inputBegan = UserInputService.InputBegan:Connect(function(i, g)
        if g or not knockbackFlyEnabled then return end
        if i.KeyCode == Enum.KeyCode.W then knockbackMoveVec += Vector3.new(0, 0, -1) end
        if i.KeyCode == Enum.KeyCode.S then knockbackMoveVec += Vector3.new(0, 0, 1) end
        if i.KeyCode == Enum.KeyCode.A then knockbackMoveVec += Vector3.new(-1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.D then knockbackMoveVec += Vector3.new(1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.Space then knockbackMoveVec += Vector3.new(0, 1, 0) end
        if i.KeyCode == Enum.KeyCode.LeftControl then knockbackMoveVec += Vector3.new(0, -1, 0) end
    end)
    knockbackInputConnections.inputEnded = UserInputService.InputEnded:Connect(function(i)
        if not knockbackFlyEnabled then return end
        if i.KeyCode == Enum.KeyCode.W then knockbackMoveVec -= Vector3.new(0, 0, -1) end
        if i.KeyCode == Enum.KeyCode.S then knockbackMoveVec -= Vector3.new(0, 0, 1) end
        if i.KeyCode == Enum.KeyCode.A then knockbackMoveVec -= Vector3.new(-1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.D then knockbackMoveVec -= Vector3.new(1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.Space then knockbackMoveVec -= Vector3.new(0, 1, 0) end
        if i.KeyCode == Enum.KeyCode.LeftControl then knockbackMoveVec -= Vector3.new(0, -1, 0) end
    end)
    Connections.knockbackInputBegan = knockbackInputConnections.inputBegan
    Connections.knockbackInputEnded = knockbackInputConnections.inputEnded
end

function Module.toggleAmberCollectionKnockback(value)
    amberCollectionEnabled = value
    if value then
        processedPrompts = {}
        currentAmberTarget = nil
        knockbackReturningToBase = false
        Module.enableNoclip()
        Module.startKnockbackFly()
        Module.setupKnockbackInput()
        amberCollectionCoroutine = task.spawn(function()
            while amberCollectionEnabled do
                pcall(function()
                    Module.amberCollectionLoopKnockback()
                end)
                task.wait(0.05)
            end
        end)
    else
        amberCollectionEnabled = false
        currentAmberTarget = nil
        knockbackReturningToBase = false
        Module.disableNoclip()
        Module.stopKnockbackFly()
        for key, connection in pairs(knockbackInputConnections) do
            if connection then
                connection:Disconnect()
            end
        end
        knockbackInputConnections = {}
        if amberCollectionCoroutine then
            task.cancel(amberCollectionCoroutine)
            amberCollectionCoroutine = nil
        end
    end
end

function Module.getClosestBoss()
    local closest = nil
    local shortestDist = math.huge
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "D-Rex Boss" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortestDist then
                shortestDist = dist
                closest = npc
            end
        end
    end
    return closest
end

function Module.anchorToBoss(targetBoss)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetBoss:FindFirstChild("HumanoidRootPart")
    if not targetRoot then
        return false
    end
    local dir = -(targetRoot.CFrame.LookVector) * bossBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.bossTeleportLoop()
    if not bossTeleportEnabled then return end
    if not currentBossTarget or not currentBossTarget:IsDescendantOf(workspace) or currentBossTarget.Humanoid.Health <= 0 then
        currentBossTarget = Module.getClosestBoss()
        if not currentBossTarget then
            return
        end
    end
    if hrp and currentBossTarget.HumanoidRootPart then
        Module.anchorToBoss(currentBossTarget)
    end
end

function Module.toggleBossTeleport(value)
    bossTeleportEnabled = value
    if value then
        currentBossTarget = Module.getClosestBoss()
        if currentBossTarget then
            Module.anchorToBoss(currentBossTarget)
        end
        bossTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.bossTeleportLoop()
        end)
        Connections.bossTeleport = bossTeleportConnection
    else
        currentBossTarget = nil
        if bossTeleportConnection then
            bossTeleportConnection:Disconnect()
            bossTeleportConnection = nil
            Connections.bossTeleport = nil
        end
    end
end

function Module.switchToNextBoss()
    local allBosses = {}
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "D-Rex Boss" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            table.insert(allBosses, npc)
        end
    end
    if #allBosses == 0 then
        return nil
    elseif #allBosses == 1 then
        return allBosses[1]
    else
        for _, npc in pairs(allBosses) do
            if npc ~= currentBossTarget then
                return npc
            end
        end
        return allBosses[1]
    end
end

function Module.cleanup()
    for key, connection in pairs(Connections) do
        if connection then
            connection:Disconnect()
            Connections[key] = nil
        end
    end
    Module.stopSwim()
    Module.toggleWalkspeed(false)
    Module.toggleNPCTeleport(false)
    Module.toggleAmberCollection(false)
    Module.toggleAmberCollectionSwim(false)
    Module.toggleESP(false)
    Module.toggleHighlight(false)
    teleporting = false
    currentTarget = nil
    Module.disableAntiVoid()
    Module.toggleBossTeleport(false)
    Module.stopVoidDetection()
    Module.toggleStaffWatch(false)
    Module.disableAntiAfk()
    Module.disableNoclip()
    AUTO_SPAWN_ENABLED = false
    Module.stopKnockbackFly()
    for key, connection in pairs(knockbackInputConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    knockbackInputConnections = {}
end

return Module
