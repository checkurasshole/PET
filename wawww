local Module = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local folder = workspace:WaitForChild("Humanoids")
local camera = workspace.CurrentCamera

Module.OrgDestroyHeight = workspace.FallenPartsDestroyHeight
Module.antivoidloop = nil
Module.antivoidWasEnabled = false
Module.swimming = false
Module.oldgrav = workspace.Gravity
Module.swimbeat = nil
Module.gravReset = nil
Module.noclipConnection = nil
Module.isSwimmingToDestination = false
Module.swimDestination = Vector3.new(0, 0, 0)
Module.swimSpeed = 100
Module.processedPrompts = {}
Module.amberCollectionEnabled = false
Module.currentAmberTarget = nil
Module.isCollecting = false
Module.amberCollectionCoroutine = nil
Module.antivoidEnabled = false
Module.voidDetectionLoop = nil
Module.floatingEnabled = false
Module.floatPart = nil
Module.floatName = "AmberFarmFloat_" .. math.random(1000, 9999)
Module.amberPausedForVoid = false
Module.staffwatchjoin = nil
Module.staffwatchEnabled = false
Module.antiAfkEnabled = false
Module.antiAfkConnections = {}
Module.lastCollectionTime = tick()
Module.collectionTimeout = 30
Module.noclipEnabled = false
Module.AUTO_SPAWN_ENABLED = false
Module.SPAWN_ARGS = { [1] = "Gallimimus" }
Module.lastVisibleGuis = {}
Module.SPAWN_COOLDOWN = 5
Module.lastSpawnTime = 0
Module.isSpawning = false
Module.espEnabled = false
Module.highlightEnabled = false
Module.teleporting = false
Module.npcTeleportEnabled = false
Module.currentTarget = nil
Module.currentNPCTarget = nil
Module.playerIndex = 1
Module.targetMovingPlayers = true
Module.targetStillPlayers = true
Module.behindDistance = 5
Module.npcBehindDistance = 5
Module.walkspeedEnabled = false
Module.customWalkspeed = 16
Module.HumanModCons = {}
Module.activeESPElements = {}
Module.activeHighlights = {}
Module.npcTeleportConnection = nil
Module.Connections = {}
Module.amberAttemptStartTime = 0
Module.amberAttemptTimeout = 15
Module.lastPlayerPosition = Vector3.new(0, 0, 0)
Module.stuckCheckCounter = 0
Module.stuckThreshold = 30
Module.v2SwitchedToV1 = false
Module.autoAttackEnabled = false
Module.autoHeavyEnabled = false
Module.autoAttackConnection = nil
Module.autoHeavyConnection = nil
Module.knockbackFlying = false
Module.knockbackAmberEnabled = false
Module.knockbackSpeed = 8
Module.knockbackMoveVec = Vector3.zero
Module.knockbackConnections = {}
Module.bossTeleportEnabled = false
Module.bossTeleportConnection = nil

function Module.toggleHighlight(value)
    Module.highlightEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyHighlight(model)
        end
    else
        for model, highlight in pairs(Module.activeHighlights) do
            if highlight and highlight.Parent then
                highlight:Destroy()
            end
            if Module.Connections["Highlight_" .. tostring(model)] then
                Module.Connections["Highlight_" .. tostring(model)]:Disconnect()
                Module.Connections["Highlight_" .. tostring(model)] = nil
            end
        end
        Module.activeHighlights = {}
    end
end

function Module.getValidPlayers()
    local players = Players:GetPlayers()
    local validPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
           player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local isMoving = Module.isPlayerMoving(player)
            if (isMoving and Module.targetMovingPlayers) or (not isMoving and Module.targetStillPlayers) then
                table.insert(validPlayers, player)
            end
        end
    end
    return validPlayers
end

function Module.getNextTarget()
    local validPlayers = Module.getValidPlayers()
    if #validPlayers == 0 then
        return nil
    end
    Module.playerIndex = ((Module.playerIndex - 1) % #validPlayers) + 1
    return validPlayers[Module.playerIndex]
end

function Module.anchorToPlayer(targetPlayer)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetPlayer.Character.HumanoidRootPart
    local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    local targetLookVector = targetRoot.CFrame.LookVector
    if targetHumanoid and targetHumanoid.MoveDirection.Magnitude > 0.1 then
        local moveDirection = targetHumanoid.MoveDirection
        targetLookVector = Vector3.new(moveDirection.X, 0, moveDirection.Z).Unit
    end
    local behindPosition = targetRoot.Position - (targetLookVector * Module.behindDistance)
    behindPosition = Vector3.new(behindPosition.X, targetRoot.Position.Y, behindPosition.Z)
    local newCFrame = CFrame.lookAt(behindPosition, targetRoot.Position)
    localPlayer.Character.HumanoidRootPart.CFrame = newCFrame
    localPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.teleportLoop()
    if not Module.teleporting then return end
    if not Module.currentTarget or Module.isPlayerDead(Module.currentTarget) then
        Module.currentTarget = Module.getNextTarget()
        if Module.currentTarget then
            Module.anchorToPlayer(Module.currentTarget)
        else
            task.wait(1)
            return
        end
    end
    if localPlayer.Character and Module.currentTarget.Character then
        local myPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = Module.currentTarget.Character.HumanoidRootPart.Position
        local targetLookVector = Module.currentTarget.Character.HumanoidRootPart.CFrame.LookVector
        local intendedPosition = targetPosition - (targetLookVector * Module.behindDistance)
        local distanceFromIntended = (myPosition - intendedPosition).Magnitude
        if distanceFromIntended > 2 then
            Module.anchorToPlayer(Module.currentTarget)
        end
    end
end

function Module.getClosestNPC()
    local closest = nil
    local shortestDist = math.huge
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortestDist then
                shortestDist = dist
                closest = npc
            end
        end
    end
    return closest
end

function Module.anchorToNPC(targetNPC)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetNPC:FindFirstChild("HumanoidRootPart")
    if not targetRoot then
        return false
    end
    local dir = -(targetRoot.CFrame.LookVector) * Module.npcBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.npcTeleportLoop()
    if not Module.npcTeleportEnabled then return end
    if not Module.currentNPCTarget or not Module.currentNPCTarget:IsDescendantOf(workspace) or Module.currentNPCTarget.Humanoid.Health <= 0 then
        Module.currentNPCTarget = Module.getClosestNPC()
        if not Module.currentNPCTarget then
            return
        end
    end
    if hrp and Module.currentNPCTarget.HumanoidRootPart then
        Module.anchorToNPC(Module.currentNPCTarget)
    end
end

function Module.toggleNPCTeleport(value)
    Module.npcTeleportEnabled = value
    if value then
        Module.currentNPCTarget = Module.getClosestNPC()
        if Module.currentNPCTarget then
            Module.anchorToNPC(Module.currentNPCTarget)
        end
        Module.npcTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.npcTeleportLoop()
        end)
        Module.Connections.npcTeleport = Module.npcTeleportConnection
    else
        Module.currentNPCTarget = nil
        if Module.npcTeleportConnection then
            Module.npcTeleportConnection:Disconnect()
            Module.npcTeleportConnection = nil
            Module.Connections.npcTeleport = nil
        end
    end
end

function Module.switchToNextNPC()
    local allNPCs = {}
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            table.insert(allNPCs, npc)
        end
    end
    if #allNPCs == 0 then
        return nil
    elseif #allNPCs == 1 then
        return allNPCs[1]
    else
        for _, npc in pairs(allNPCs) do
            if npc ~= Module.currentNPCTarget then
                return npc
            end
        end
        return allNPCs[1]
    end
end

function Module.anchorToBoss()
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local boss = folder:FindFirstChild("D-Rex Boss")
    if not boss or not boss:FindFirstChild("HumanoidRootPart") or not boss:FindFirstChild("Humanoid") or boss.Humanoid.Health <= 0 then
        return false
    end
    local targetRoot = boss.HumanoidRootPart
    local dir = -(targetRoot.CFrame.LookVector) * Module.npcBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.bossTeleportLoop()
    if not Module.bossTeleportEnabled then return end
    local boss = folder:FindFirstChild("D-Rex Boss")
    if not boss or not boss:FindFirstChild("Humanoid") or boss.Humanoid.Health <= 0 then
        return
    end
    if hrp and boss.HumanoidRootPart then
        Module.anchorToBoss()
    end
end

function Module.toggleBossTeleport(value)
    Module.bossTeleportEnabled = value
    if value then
        Module.anchorToBoss()
        Module.bossTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.bossTeleportLoop()
        end)
        Module.Connections.bossTeleport = Module.bossTeleportConnection
    else
        if Module.bossTeleportConnection then
            Module.bossTeleportConnection:Disconnect()
            Module.bossTeleportConnection = nil
            Module.Connections.bossTeleport = nil
        end
    end
end

function Module.deepSearchProximityPrompts(obj, path)
    local prompts = {}
    path = path or obj.Name
    if obj:IsA("ProximityPrompt") then
        table.insert(prompts, {prompt = obj, path = path, parent = obj.Parent})
        return prompts
    end
    for _, child in pairs(obj:GetChildren()) do
        local childPath = path .. "." .. child.Name
        local childPrompts = Module.deepSearchProximityPrompts(child, childPath)
        for _, promptData in pairs(childPrompts) do
            table.insert(prompts, promptData)
        end
    end
    return prompts
end

function Module.getBestPosition(obj)
    local function findPartPosition(searchObj)
        if searchObj:IsA("BasePart") then
            return searchObj.Position
        elseif searchObj:IsA("Model") and searchObj.PrimaryPart then
            return searchObj.PrimaryPart.Position
        else
            for _, child in pairs(searchObj:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        return nil
    end
    local pos = findPartPosition(obj)
    if pos then return pos end
    local current = obj.Parent
    while current and current ~= Workspace do
        pos = findPartPosition(current)
        if pos then return pos end
        current = current.Parent
    end
    return nil
end

function Module.getAllAmberPrompts()
    local itemSpawn = Workspace:FindFirstChild("ItemSpawn")
    if not itemSpawn then
        return {}
    end
    local amber = itemSpawn:FindFirstChild("Amber")
    if not amber then
        return {}
    end
    local allPrompts = {}
    for _, child in pairs(amber:GetChildren()) do
        if child.Name == "AmberSpawn" then
            local prompts = Module.deepSearchProximityPrompts(child)
            for _, promptData in pairs(prompts) do
                local promptId = tostring(promptData.prompt)
                if not Module.processedPrompts[promptId] and promptData.prompt.Parent and promptData.prompt.Enabled then
                    table.insert(allPrompts, promptData)
                end
            end
        end
    end
    return allPrompts
end

function Module.fireProximityPromptSwim(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        Module.processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        Module.processedPrompts[promptId] = true
        return false
    end
    if not Module.swimming then
        Module.startSwim()
        task.wait(0.2)
    end
    Module.swimToDestination(targetPosition)
    local timeoutCounter = 0
    local maxTimeout = 50
    while Module.isSwimmingToDestination and timeoutCounter < maxTimeout do
        task.wait(0.1)
        timeoutCounter = timeoutCounter + 1
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
    end
    if hrp and prompt.Parent and prompt.Enabled then
        local distance = (hrp.Position - targetPosition).Magnitude
        if distance < 20 then
            local success = false
            pcall(function()
                fireproximityprompt(prompt, 0, true)
                success = true
            end)
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt)
                    success = true
                end)
            end
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt, prompt.HoldDuration or 0)
                    success = true
                end)
            end
        end
    end
    Module.processedPrompts[promptId] = true
    task.wait(0.1)
    return true
end

function Module.fireProximityPromptTween(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        Module.processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        Module.processedPrompts[promptId] = true
        return false
    end
    Module.amberAttemptStartTime = tick()
    local maxAttempts = 6
    local attempts = 0
    while attempts < maxAttempts and Module.amberCollectionEnabled do
        attempts = attempts + 1
        if not prompt.Parent or not prompt.Enabled then
            Module.processedPrompts[promptId] = true
            return false
        end
        if tick() - Module.amberAttemptStartTime > Module.amberAttemptTimeout then
            Module.processedPrompts[promptId] = true
            return false
        end
        for _, part in pairs(localPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        local isCloseEnough = Module.moveTowardsTarget(targetPosition, 50, 5)
        task.wait(0.15)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
        if hrp and prompt.Parent and prompt.Enabled then
            local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
            local distance = (hrp.Position - targetPosAbove).Magnitude
            if distance < 30 then
                local success = false
                pcall(function()
                    fireproximityprompt(prompt, 0, true)
                    success = true
                end)
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt)
                        success = true
                    end)
                end
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt, prompt.HoldDuration or 0)
                        success = true
                    end)
                end
                if success then
                    Module.lastCollectionTime = tick()
                end
                break
            end
        end
    end
    for _, part in pairs(localPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    Module.processedPrompts[promptId] = true
    task.wait(0.05)
    return true
end

function Module.amberCollectionLoopSwim()
    if not Module.amberCollectionEnabled or Module.isCollecting then 
        return 
    end
    Module.isCollecting = true
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        Module.currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptSwim(Module.currentAmberTarget)
    else
        Module.processedPrompts = {}
        Module.currentAmberTarget = nil
        Module.stopSwim()
        task.wait(1)
    end
    Module.isCollecting = false
end

function Module.amberCollectionLoopTween()
    if not Module.amberCollectionEnabled then 
        return 
    end
    if Module.amberPausedForVoid then
        return
    end
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        hrp = localPlayer.Character.HumanoidRootPart
        local currentPos = hrp.Position
        local distanceMoved = (currentPos - Module.lastPlayerPosition).Magnitude
        if distanceMoved < 0.5 then
            Module.stuckCheckCounter = Module.stuckCheckCounter + 1
        else
            Module.stuckCheckCounter = 0
        end
        Module.lastPlayerPosition = currentPos
        if Module.stuckCheckCounter > Module.stuckThreshold and not Module.v2SwitchedToV1 then
            Module.v2SwitchedToV1 = true
            return
        end
    end
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        Module.currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptTween(Module.currentAmberTarget)
    else
        Module.currentAmberTarget = nil
        Module.processedPrompts = {}
    end
end

function Module.toggleAmberCollectionSwim(value)
    Module.amberCollectionEnabled = value
    if value then
        Module.processedPrompts = {}
        Module.currentAmberTarget = nil
        Module.amberCollectionCoroutine = task.spawn(function()
            while Module.amberCollectionEnabled do
                pcall(function()
                    Module.amberCollectionLoopSwim()
                end)
                task.wait(0.3)
            end
        end)
    else
        Module.amberCollectionEnabled = false
        Module.currentAmberTarget = nil
        Module.isCollecting = false
        Module.stopSwim()
        if Module.amberCollectionCoroutine then
            task.cancel(Module.amberCollectionCoroutine)
            Module.amberCollectionCoroutine = nil
        end
    end
end

function Module.toggleAmberCollection(value)
    Module.amberCollectionEnabled = value
    if value then
        Module.lastCollectionTime = tick()
        Module.enableAntiVoid()
        Module.startVoidDetection()
        Module.processedPrompts = {}
        Module.currentAmberTarget = nil
        Module.v2SwitchedToV1 = false
        Module.stuckCheckCounter = 0
        Module.lastPlayerPosition = Vector3.new(0, 0, 0)
        Module.amberCollectionCoroutine = task.spawn(function()
            while Module.amberCollectionEnabled do
                pcall(function()
                    if Module.v2SwitchedToV1 then
                        Module.amberCollectionLoopSwim()
                        if not Module.swimming then
                            Module.v2SwitchedToV1 = false
                            Module.stuckCheckCounter = 0
                        end
                    else
                        Module.amberCollectionLoopTween()
                    end
                end)
                task.wait(0.05)
            end
        end)
    else
        Module.amberCollectionEnabled = false
        Module.currentAmberTarget = nil
        Module.amberPausedForVoid = false
        Module.v2SwitchedToV1 = false
        Module.stuckCheckCounter = 0
        Module.stopVoidDetection()
        Module.disableAntiVoid()
        if Module.amberCollectionCoroutine then
            task.cancel(Module.amberCollectionCoroutine)
            Module.amberCollectionCoroutine = nil
        end
    end
end

function Module.stabilizeCharacter()
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if currentHrp then
        currentHrp.RotVelocity = Vector3.zero
        currentHrp.AssemblyAngularVelocity = Vector3.zero
    end
end

function Module.applyKnockbackThrust()
    if not Module.knockbackFlying then return end
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return end
    if Module.knockbackMoveVec.Magnitude > 0 then
        local dir = camera.CFrame:VectorToWorldSpace(Module.knockbackMoveVec).Unit
        local thrust = dir * math.clamp(Module.knockbackSpeed, 1, 20)
        thrust = Vector3.new(
            math.clamp(thrust.X, -10, 10),
            math.clamp(thrust.Y, -5, 5),
            math.clamp(thrust.Z, -10, 10)
        )
        pcall(function()
            local requestKnockback = ReplicatedStorage["shared/network/init@GlobalEvents"].requestKnockback
            firesignal(requestKnockback.OnClientEvent, 15, 0.6, thrust)
        end)
    end
end

function Module.moveToAmber(targetPosition)
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return false end
    local distance = (currentHrp.Position - targetPosition).Magnitude
    if distance < 15 then
        return true
    end
    local direction = (targetPosition - currentHrp.Position).Unit
    local thrust = direction * math.clamp(Module.knockbackSpeed, 1, 20)
    thrust = Vector3.new(
        math.clamp(thrust.X, -10, 10),
        math.clamp(thrust.Y, -5, 5),
        math.clamp(thrust.Z, -10, 10)
    )
    pcall(function()
        local requestKnockback = ReplicatedStorage["shared/network/init@GlobalEvents"].requestKnockback
        firesignal(requestKnockback.OnClientEvent, 15, 0.6, thrust)
    end)
    return false
end

function Module.fireKnockbackAmberPrompt(promptData)
    if not fireproximityprompt then return false end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        Module.processedPrompts[promptId] = true
        return false
    end
    local success = false
    pcall(function()
        fireproximityprompt(prompt, 0, true)
        success = true
    end)
    if not success then
        pcall(function()
            fireproximityprompt(prompt)
            success = true
        end)
    end
    if not success then
        pcall(function()
            fireproximityprompt(prompt, prompt.HoldDuration or 0)
        end)
    end
    Module.processedPrompts[promptId] = true
    return true
end

function Module.knockbackAmberLoop()
    if not Module.knockbackAmberEnabled then return end
    local currentHrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not currentHrp then return end
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        table.sort(availablePrompts, function(a, b)
            local posA = Module.getBestPosition(a.prompt)
            local posB = Module.getBestPosition(b.prompt)
            if posA and posB then
                local distA = (currentHrp.Position - posA).Magnitude
                local distB = (currentHrp.Position - posB).Magnitude
                return distA < distB
            end
            return false
        end)
        Module.currentAmberTarget = availablePrompts[1]
        local targetPos = Module.getBestPosition(Module.currentAmberTarget.prompt)
        if targetPos then
            local isClose = Module.moveToAmber(targetPos)
            if isClose then
                Module.fireKnockbackAmberPrompt(Module.currentAmberTarget)
                task.wait(0.2)
            end
        end
    else
        Module.processedPrompts = {}
        Module.currentAmberTarget = nil
    end
end

function Module.toggleKnockbackAmber(value)
    Module.knockbackAmberEnabled = value
    if value then
        if not Module.knockbackFlying then
            Module.knockbackFlying = true
            if Module.knockbackConnections.flyLoop then
                Module.knockbackConnections.flyLoop:Disconnect()
            end
            Module.knockbackConnections.flyLoop = RunService.Heartbeat:Connect(function()
                if Module.knockbackFlying then
                    Module.stabilizeCharacter()
                    Module.applyKnockbackThrust()
                end
            end)
            Module.Connections.knockbackFly = Module.knockbackConnections.flyLoop
        end
        if Module.knockbackConnections.amberLoop then
            Module.knockbackConnections.amberLoop:Disconnect()
        end
        Module.knockbackConnections.amberLoop = RunService.Heartbeat:Connect(function()
            if Module.knockbackAmberEnabled then
                pcall(Module.knockbackAmberLoop)
            end
        end)
        Module.Connections.knockbackAmber = Module.knockbackConnections.amberLoop
    else
        if Module.knockbackConnections.amberLoop then
            Module.knockbackConnections.amberLoop:Disconnect()
            Module.knockbackConnections.amberLoop = nil
            Module.Connections.knockbackAmber = nil
        end
        Module.currentAmberTarget = nil
        Module.knockbackFlying = false
        if Module.knockbackConnections.flyLoop then
            Module.knockbackConnections.flyLoop:Disconnect()
            Module.knockbackConnections.flyLoop = nil
            Module.Connections.knockbackFly = nil
        end
    end
end

function Module.updateKnockbackSpeed(value)
    Module.knockbackSpeed = value
end

function Module.cleanup()
    for key, connection in pairs(Module.Connections) do
        if connection then
            connection:Disconnect()
            Module.Connections[key] = nil
        end
    end
    Module.stopSwim()
    Module.toggleWalkspeed(false)
    Module.toggleNPCTeleport(false)
    Module.toggleBossTeleport(false)
    Module.toggleAmberCollection(false)
    Module.toggleAmberCollectionSwim(false)
    Module.toggleKnockbackAmber(false)
    Module.toggleESP(false)
    Module.toggleHighlight(false)
    Module.teleporting = false
    Module.currentTarget = nil
    Module.disableAntiVoid()
    Module.stopVoidDetection()
    Module.toggleStaffWatch(false)
    Module.disableAntiAfk()
    Module.disableNoclip()
    Module.AUTO_SPAWN_ENABLED = false
end

function Module.init()
    UserInputService.InputBegan:Connect(function(i, g)
        if g then return end
        if i.KeyCode == Enum.KeyCode.W then Module.knockbackMoveVec = Module.knockbackMoveVec + Vector3.new(0, 0, -1) end
        if i.KeyCode == Enum.KeyCode.S then Module.knockbackMoveVec = Module.knockbackMoveVec + Vector3.new(0, 0, 1) end
        if i.KeyCode == Enum.KeyCode.A then Module.knockbackMoveVec = Module.knockbackMoveVec + Vector3.new(-1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.D then Module.knockbackMoveVec = Module.knockbackMoveVec + Vector3.new(1, 0, 0) end
        if i.KeyCode == Enum.KeyCode.Space then Module.knockbackMoveVec.executeAutoAttack()
    pcall(function()
        local requestSkill = ReplicatedStorage["@rbxts/wcs:source/networking@GlobalEvents"].requestSkill
        requestSkill:FireServer({
            blobs = {
                0.5600000023841858,
                workspace:GetServerTimeNow(),
                false
            },
            buffer = buffer.fromstring("\8\0\0\0M1Attack\1\3\0\0\0\1\1\1")
        })
    end)
end

function Module.executeAutoHeavy()
    pcall(function()
        local onHeavyRequest = ReplicatedStorage["shared/network/init@GlobalEvents"].onHeavyRequest
        onHeavyRequest:FireServer()
    end)
end

function Module.executeInstantDespawn()
    pcall(function()
        local despawn = ReplicatedStorage["shared/network/init@GlobalEvents"].despawn
        despawn:FireServer()
    end)
end

function Module.toggleAutoAttack(value)
    Module.autoAttackEnabled = value
    if value then
        if Module.autoAttackConnection then
            Module.autoAttackConnection:Disconnect()
        end
        Module.autoAttackConnection = RunService.Heartbeat:Connect(function()
            if Module.autoAttackEnabled then
                Module.executeAutoAttack()
            end
        end)
        Module.Connections.autoAttack = Module.autoAttackConnection
    else
        if Module.autoAttackConnection then
            Module.autoAttackConnection:Disconnect()
            Module.autoAttackConnection = nil
            Module.Connections.autoAttack = nil
        end
    end
end

function Module.toggleAutoHeavy(value)
    Module.autoHeavyEnabled = value
    if value then
        if Module.autoHeavyConnection then
            Module.autoHeavyConnection:Disconnect()
        end
        Module.autoHeavyConnection = RunService.Heartbeat:Connect(function()
            if Module.autoHeavyEnabled then
                Module.executeAutoHeavy()
            end
        end)
        Module.Connections.autoHeavy = Module.autoHeavyConnection
    else
        if Module.autoHeavyConnection then
            Module.autoHeavyConnection:Disconnect()
            Module.autoHeavyConnection = nil
            Module.Connections.autoHeavy = nil
        end
    end
end

function Module.getRoot(character)
    if not character then return nil end
    return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
end

function Module.enableAntiVoid()
    if Module.antivoidloop then
        Module.antivoidloop:Disconnect()
        Module.antivoidloop = nil
    end
    Module.antivoidloop = RunService.Stepped:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if root and root.Position.Y <= Module.OrgDestroyHeight + 25 then
            root.Velocity = root.Velocity + Vector3.new(0, 250, 0)
        end
    end)
    Module.Connections.antivoid = Module.antivoidloop
    Module.antivoidEnabled = true
end

function Module.disableAntiVoid()
    if Module.antivoidloop then
        Module.antivoidloop:Disconnect()
        Module.antivoidloop = nil
        Module.Connections.antivoid = nil
    end
    Module.antivoidEnabled = false
end

function Module.executeSpawn()
    local currentTime = tick()
    if currentTime - Module.lastSpawnTime < Module.SPAWN_COOLDOWN then
        return false
    end
    if Module.isSpawning then
        return false
    end
    Module.isSpawning = true
    Module.lastSpawnTime = currentTime
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("shared/network/init@GlobalEvents", 9e9):WaitForChild("spawn", 9e9):FireServer(unpack(Module.SPAWN_ARGS))
    end)
    Module.isSpawning = false
    return true
end

function Module.getFullPath(obj)
    local path = obj.Name
    local parent = obj.Parent
    while parent and parent ~= game do
        path = parent.Name .. "." .. path
        parent = parent.Parent
    end
    return path
end

function Module.checkForNewAppGuis(currentGuis)
    local newAppGuis = {}
    for path, _ in pairs(currentGuis) do
        if not Module.lastVisibleGuis[path] and string.find(string.lower(path), "playergui%.app") ~= nil then
            table.insert(newAppGuis, path)
        end
    end
    return newAppGuis
end

function Module.scanForVisibleGuis()
    if not Module.AUTO_SPAWN_ENABLED then return end
    local currentGuis = {}
    local function scanGui(obj)
        if obj:IsA("GuiObject") and obj.Visible then
            local fullPath = Module.getFullPath(obj)
            currentGuis[fullPath] = true
        end
        for _, sub in ipairs(obj:GetChildren()) do
            scanGui(sub)
        end
    end
    pcall(function()
        scanGui(localPlayer:WaitForChild("PlayerGui"))
    end)
    local newAppGuis = Module.checkForNewAppGuis(currentGuis)
    if #newAppGuis > 0 then
        Module.executeSpawn()
    end
    Module.lastVisibleGuis = currentGuis
end

function Module.isAboveTerrain(position)
    local region = Region3.new(
        Vector3.new(position.X - 1, position.Y - 200, position.Z - 1),
        Vector3.new(position.X + 1, position.Y, position.Z + 1)
    )
    local terrainRegion = Workspace.Terrain:ReadVoxels(region, 4)
    local size = terrainRegion.Size
    for x = 1, size.X do
        for y = 1, size.Y do
            for z = 1, size.Z do
                if terrainRegion:get(x, y, z).Value > 0 then
                    return true
                end
            end
        end
    end
    return false
end

function Module.hasGroundBelow(position, maxDistance)
    maxDistance = maxDistance or 50
    if Module.isAboveTerrain(position) then
        return true
    end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {localPlayer.Character}
    local raycastResult = Workspace:Raycast(position, Vector3.new(0, -maxDistance, 0), raycastParams)
    return raycastResult ~= nil
end

function Module.enableFloating()
    if Module.floatingEnabled or not localPlayer.Character then return end
    local pchar = localPlayer.Character
    local root = Module.getRoot(pchar)
    if not root then return end
    Module.floatingEnabled = true
    Module.floatPart = Instance.new('Part')
    Module.floatPart.Name = Module.floatName
    Module.floatPart.Parent = pchar
    Module.floatPart.Transparency = 1
    Module.floatPart.Size = Vector3.new(2, 0.2, 1.5)
    Module.floatPart.Anchored = true
    Module.floatPart.CFrame = root.CFrame * CFrame.new(0, -3.1, 0)
    local floatConnection
    floatConnection = RunService.Heartbeat:Connect(function()
        if Module.floatingEnabled and pchar:FindFirstChild(Module.floatName) and Module.getRoot(pchar) then
            Module.floatPart.CFrame = Module.getRoot(pchar).CFrame * CFrame.new(0, -3.1, 0)
        else
            if floatConnection then
                floatConnection:Disconnect()
            end
        end
    end)
end

function Module.disableFloating()
    if not Module.floatingEnabled then return end
    Module.floatingEnabled = false
    if Module.floatPart then
        Module.floatPart:Destroy()
        Module.floatPart = nil
    end
    local pchar = localPlayer.Character
    if pchar and pchar:FindFirstChild(Module.floatName) then
        pchar:FindFirstChild(Module.floatName):Destroy()
    end
end

function Module.startVoidDetection()
    if Module.voidDetectionLoop then
        Module.voidDetectionLoop:Disconnect()
    end
    Module.voidDetectionLoop = RunService.Heartbeat:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if not root then return end
        local position = root.Position
        local hasGround = Module.hasGroundBelow(position, 100)
        if not hasGround then
            if Module.amberCollectionEnabled and not Module.amberPausedForVoid then
                Module.amberPausedForVoid = true
            end
            if not Module.floatingEnabled then
                Module.enableFloating()
            end
        else
            if Module.amberPausedForVoid then
                Module.amberPausedForVoid = false
            end
            if Module.floatingEnabled then
                Module.disableFloating()
            end
        end
    end)
end

function Module.stopVoidDetection()
    if Module.voidDetectionLoop then
        Module.voidDetectionLoop:Disconnect()
        Module.voidDetectionLoop = nil
    end
    Module.disableFloating()
    Module.amberPausedForVoid = false
end

function Module.toggleStaffWatch(value)
    Module.staffwatchEnabled = value
    if value then
        if Module.staffwatchjoin then
            Module.staffwatchjoin:Disconnect()
        end
        if game.CreatorType == Enum.CreatorType.Group then
            Module.staffwatchjoin = Players.PlayerAdded:Connect(function(player)
                task.wait()
            end)
        end
    else
        if Module.staffwatchjoin then
            Module.staffwatchjoin:Disconnect()
            Module.staffwatchjoin = nil
        end
    end
end

function Module.enableAntiAfk()
    if Module.antiAfkEnabled then return end
    Module.antiAfkEnabled = true
    Module.antiAfkConnections.virtualUser = UserInputService.InputBegan:Connect(function() end)
    Module.antiAfkConnections.periodicInput = task.spawn(function()
        while Module.antiAfkEnabled do
            task.wait(300)
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end
    end)
    Module.antiAfkConnections.characterMovement = task.spawn(function()
        while Module.antiAfkEnabled do
            task.wait(600)
            local char = localPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local root = char.HumanoidRootPart
                local originalPos = root.CFrame
                root.CFrame = originalPos + Vector3.new(0.1, 0, 0)
                task.wait(0.1)
                root.CFrame = originalPos
            end
        end
    end)
    Module.antiAfkConnections.idleConnection = localPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

function Module.disableAntiAfk()
    Module.antiAfkEnabled = false
    for name, connection in pairs(Module.antiAfkConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            else
                task.cancel(connection)
            end
        end
    end
    Module.antiAfkConnections = {}
end

function Module.noclip()
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

function Module.enableNoclip()
    if Module.noclipConnection then
        Module.noclipConnection:Disconnect()
        Module.noclipConnection = nil
    end
    Module.noclipConnection = RunService.Stepped:Connect(Module.noclip)
    Module.Connections.noclip = Module.noclipConnection
    Module.noclipEnabled = true
end

function Module.disableNoclip()
    if Module.noclipConnection then
        Module.noclipConnection:Disconnect()
        Module.noclipConnection = nil
        Module.Connections.noclip = nil
    end
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    Module.noclipEnabled = false
end

function Module.startSwim()
    if not Module.swimming and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        Module.oldgrav = workspace.Gravity
        workspace.Gravity = 0
        local swimDied = function()
            workspace.Gravity = Module.oldgrav
            Module.swimming = false
            Module.disableNoclip()
            Module.Connections.swimDied = nil
        end
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        Module.gravReset = Humanoid.Died:Connect(swimDied)
        Module.Connections.swimDied = Module.gravReset
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, false)
        end
        Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
        Module.swimbeat = RunService.Heartbeat:Connect(function()
            pcall(function()
                local hrp = localPlayer.Character.HumanoidRootPart
                local humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                if Module.isSwimmingToDestination then
                    local currentPos = hrp.Position
                    local direction = (Module.swimDestination - currentPos).Unit
                    local distance = (Module.swimDestination - currentPos).Magnitude
                    if distance < 5 then
                        Module.isSwimmingToDestination = false
                        hrp.Velocity = Vector3.new(0, 0, 0)
                    else
                        hrp.Velocity = direction * Module.swimSpeed
                    end
                else
                    local moveVector = humanoid.MoveDirection
                    local camera = workspace.CurrentCamera
                    local cameraCFrame = camera.CFrame
                    local worldMoveVector = Vector3.new(0, 0, 0)
                    if moveVector.Magnitude > 0 then
                        local cameraRight = cameraCFrame.RightVector
                        local cameraForward = -cameraCFrame.LookVector
                        cameraRight = Vector3.new(cameraRight.X, 0, cameraRight.Z).Unit
                        cameraForward = Vector3.new(cameraForward.X, 0, cameraForward.Z).Unit
                        worldMoveVector = (cameraRight * moveVector.X + cameraForward * moveVector.Z)
                    end
                    local verticalMovement = 0
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        verticalMovement = 1
                    elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        verticalMovement = -1
                    end
                    local finalMoveVector = Vector3.new(worldMoveVector.X, verticalMovement, worldMoveVector.Z)
                    if finalMoveVector.Magnitude > 0 then
                        hrp.Velocity = finalMoveVector.Unit * Module.swimSpeed
                    else
                        hrp.Velocity = hrp.Velocity * 0.9
                    end
                end
            end)
        end)
        Module.Connections.swimbeat = Module.swimbeat
        Module.enableNoclip()
        Module.swimming = true
        return true
    end
    return false
end

function Module.stopSwim()
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        workspace.Gravity = Module.oldgrav
        Module.swimming = false
        Module.isSwimmingToDestination = false
        if Module.gravReset then
            Module.gravReset:Disconnect()
            Module.gravReset = nil
            Module.Connections.swimDied = nil
        end
        if Module.swimbeat then
            Module.swimbeat:Disconnect()
            Module.swimbeat = nil
            Module.Connections.swimbeat = nil
        end
        Module.disableNoclip()
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, true)
        end
    end
end

function Module.swimToDestination(targetPosition)
    local character = localPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local hrp = character.HumanoidRootPart
    local currentPos = hrp.Position
    local skyPosition = Vector3.new(currentPos.X, currentPos.Y + 100, currentPos.Z)
    hrp.CFrame = CFrame.new(skyPosition)
    Module.isSwimmingToDestination = true
    Module.swimDestination = targetPosition
    if not Module.swimming then
        Module.startSwim()
    end
end

function Module.moveTowardsTarget(targetPosition, stepSize, speed)
    local char = localPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return false end
    local root = char.HumanoidRootPart
    if not targetPosition then return false end
    local currentPos = root.Position
    local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
    local direction = (targetPosAbove - currentPos).Unit
    local distance = (targetPosAbove - currentPos).Magnitude
    if distance <= 8 then
        return true
    end
    local moveDistance = math.min(stepSize or 40, distance * 0.6)
    local newPos = currentPos + (direction * moveDistance)
    if newPos.Y > currentPos.Y then
        newPos = newPos + Vector3.new(0, 5, 0)
    end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame.new(newPos, newPos + root.CFrame.LookVector)})
    tween.Completed:Connect(function()
        task.wait(0.05)
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end)
    tween:Play()
    tween.Completed:Wait()
    return false
end

function Module.getHumanoidRootPart(model)
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
end

function Module.isPlayerMoving(player)
    if not player or not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return false
    end
    return player.Character.Humanoid.MoveDirection.Magnitude > 0.1
end

function Module.isPlayerDead(player)
    return not player or not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0
end

function Module.setWalkspeed(speed)
    if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
        local Char = localPlayer.Character
        local Human = Char:FindFirstChildWhichIsA("Humanoid")
        local function WalkSpeedChange()
            if Char and Human and Module.walkspeedEnabled then
                Human.WalkSpeed = speed
            end
        end
        WalkSpeedChange()
        Module.HumanModCons.wsLoop = (Module.HumanModCons.wsLoop and Module.HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
        Module.Connections.wsLoop = Module.HumanModCons.wsLoop
        Module.HumanModCons.wsCA = (Module.HumanModCons.wsCA and Module.HumanModCons.wsCA:Disconnect() and nil) or localPlayer.CharacterAdded:Connect(function(nChar)
            Char, Human = nChar, nChar:WaitForChild("Humanoid")
            character = nChar
            hrp = nChar:WaitForChild("HumanoidRootPart")
            WalkSpeedChange()
            Module.HumanModCons.wsLoop = (Module.HumanModCons.wsLoop and Module.HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
            Module.Connections.wsLoop = Module.HumanModCons.wsLoop
        end)
        Module.Connections.wsCA = Module.HumanModCons.wsCA
    end
end

function Module.toggleWalkspeed(value)
    Module.walkspeedEnabled = value
    if value then
        Module.setWalkspeed(Module.customWalkspeed)
    else
        if Module.HumanModCons.wsLoop then
            Module.HumanModCons.wsLoop:Disconnect()
            Module.HumanModCons.wsLoop = nil
            Module.Connections.wsLoop = nil
        end
        if Module.HumanModCons.wsCA then
            Module.HumanModCons.wsCA:Disconnect()
            Module.HumanModCons.wsCA = nil
            Module.Connections.wsCA = nil
        end
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            localPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
end

function Module.updateWalkspeed(value)
    Module.customWalkspeed = value
    if Module.walkspeedEnabled then
        Module.setWalkspeed(Module.customWalkspeed)
    end
end

function Module.applyESP(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_ESP") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    local root = Module.getHumanoidRootPart(model)
    if not root then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NPC_ESP"
    billboard.Adornee = root
    billboard.Size = UDim2.new(0, 80, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = model.Name
    label.TextColor3 = Color3.fromRGB(255, 0, 0)
    label.TextStrokeTransparency = 0
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = billboard
    billboard.Parent = root
    Module.activeESPElements[model] = billboard
    local connection
    connection = humanoid.Died:Connect(function()
        billboard:Destroy()
        Module.activeESPElements[model] = nil
        if connection then
            Module.Connections["ESP_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Module.Connections["ESP_" .. tostring(model)] = connection
end

function Module.applyHighlight(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_Highlight") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    if not humanoid then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "NPC_Highlight"
    highlight.Adornee = model
    highlight.FillColor = Color3.fromRGB(100, 150, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    Module.activeHighlights[model] = highlight
    local connection
    connection = humanoid.Died:Connect(function()
        highlight:Destroy()
        Module.activeHighlights[model] = nil
        if connection then
            Module.Connections["Highlight_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Module.Connections["Highlight_" .. tostring(model)] = connection
end

function Module.toggleESP(value)
    Module.espEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyESP(model)
        end
    else
        for model, billboard in pairs(Module.activeESPElements) do
            if billboard and billboard.Parent then
                billboard:Destroy()
            end
            if Module.Connections["ESP_" .. tostring(model)] then
                Module.Connections["ESP_" .. tostring(model)]:Disconnect()
                Module.Connections["ESP_" .. tostring(model)] = nil
            end
        end
        Module.activeESPElements = {}
    end
end

function Module
