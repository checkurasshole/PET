-- DinoModule.lua
-- Core functionality module for Dino game script

local Module = {}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local HttpService = game:GetService("HttpService")
local VirtualUser = game:GetService("VirtualUser")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")
local folder = workspace:WaitForChild("Humanoids")

-- State variables
Module.State = {
    OrgDestroyHeight = workspace.FallenPartsDestroyHeight,
    antivoidloop = nil,
    antivoidWasEnabled = false,
    swimming = false,
    oldgrav = workspace.Gravity,
    swimbeat = nil,
    gravReset = nil,
    noclipConnection = nil,
    isSwimmingToDestination = false,
    swimDestination = Vector3.new(0, 0, 0),
    swimSpeed = 100,
    processedPrompts = {},
    amberCollectionEnabled = false,
    currentAmberTarget = nil,
    isCollecting = false,
    amberCollectionCoroutine = nil,
    bossTeleportEnabled = false,
    currentBossTarget = nil,
    bossBehindDistance = 5,
    bossTeleportConnection = nil,
    antivoidEnabled = false,
    voidDetectionLoop = nil,
    floatingEnabled = false,
    floatPart = nil,
    floatName = "AmberFarmFloat_" .. math.random(1000, 9999),
    amberPausedForVoid = false,
    staffwatchjoin = nil,
    staffwatchEnabled = false,
    antiAfkEnabled = false,
    antiAfkConnections = {},
    lastCollectionTime = tick(),
    collectionTimeout = 30,
    noclipEnabled = false,
    knockbackFlyEnabled = false,
    knockbackFlyConnection = nil,
    knockbackMoveVec = Vector3.zero,
    knockbackSpeed = 8,
    knockbackReturnPosition = Vector3.new(129.97, 470.59, 235.64),
    knockbackReturningToBase = false,
    knockbackInputConnections = {},
    AUTO_SPAWN_ENABLED = false,
    SPAWN_ARGS = { [1] = "Gallimimus" },
    selectedDino = "Gallimimus",
    lastVisibleGuis = {},
    SPAWN_COOLDOWN = 5,
    lastSpawnTime = 0,
    isSpawning = false,
    espEnabled = false,
    highlightEnabled = false,
    teleporting = false,
    npcTeleportEnabled = false,
    currentTarget = nil,
    currentNPCTarget = nil,
    playerIndex = 1,
    targetMovingPlayers = true,
    targetStillPlayers = true,
    behindDistance = 5,
    npcBehindDistance = 5,
    walkspeedEnabled = false,
    customWalkspeed = 16,
    HumanModCons = {},
    activeESPElements = {},
    activeHighlights = {},
    npcTeleportConnection = nil,
    Connections = {},
    amberAttemptStartTime = 0,
    amberAttemptTimeout = 15,
    lastPlayerPosition = Vector3.new(0, 0, 0),
    stuckCheckCounter = 0,
    stuckThreshold = 30,
    v2SwitchedToV1 = false,
    autoAttackEnabled = false,
    autoHeavyEnabled = false,
    autoAttackConnection = nil,
    autoHeavyConnection = nil
}

Module.allDinosaurs = {
    "Acrocanthosaurus", "Albertosaurus", "Allosaurus", "Ankylosaurus", "Apatosaurus",
    "Baryonyx", "Brachiosaurus", "Carnotaurus", "Carcharodontosaurus", "Ceratosaurus",
    "Compsognathus", "Deinonychus", "Dilophosaurus", "Diplodocus", "Dreadnoughtus",
    "Gallimimus", "Giganotosaurus", "Invictus rex", "Mamenchisaurus", "Pachycephalosaurus",
    "Parasaurolophus", "Spinosaurus", "Stegosaurus", "Suchomimus", "Therizinosaurus",
    "Triceratops", "Tyrannosaurus", "Velociraptor", "Yutyrannus"
}

-- Helper Functions
function Module.getRoot(char)
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
end

function Module.getHumanoidRootPart(model)
    return model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
end

function Module.isPlayerMoving(player)
    if not player or not player.Character or not player.Character:FindFirstChild("Humanoid") then
        return false
    end
    return player.Character.Humanoid.MoveDirection.Magnitude > 0.1
end

function Module.isPlayerDead(player)
    return not player or not player.Character or not player.Character:FindFirstChild("Humanoid") or player.Character.Humanoid.Health <= 0
end

-- Combat Functions
function Module.executeAutoAttack()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local requestSkill = ReplicatedStorage["@rbxts/wcs:source/networking@GlobalEvents"].requestSkill
        requestSkill:FireServer({
            blobs = {0.5600000023841858, workspace:GetServerTimeNow(), false},
            buffer = buffer.fromstring("\8\0\0\0M1Attack\1\3\0\0\0\1\1\1")
        })
    end)
end

function Module.executeAutoHeavy()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local onHeavyRequest = ReplicatedStorage["shared/network/init@GlobalEvents"].onHeavyRequest
        onHeavyRequest:FireServer()
    end)
end

function Module.executeInstantDespawn()
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    pcall(function()
        local despawn = ReplicatedStorage["shared/network/init@GlobalEvents"].despawn
        despawn:FireServer()
    end)
end

function Module.toggleAutoAttack(value)
    Module.State.autoAttackEnabled = value
    if value then
        if Module.State.autoAttackConnection then
            Module.State.autoAttackConnection:Disconnect()
        end
        Module.State.autoAttackConnection = RunService.Heartbeat:Connect(function()
            if Module.State.autoAttackEnabled then
                Module.executeAutoAttack()
            end
        end)
        Module.State.Connections.autoAttack = Module.State.autoAttackConnection
    else
        if Module.State.autoAttackConnection then
            Module.State.autoAttackConnection:Disconnect()
            Module.State.autoAttackConnection = nil
            Module.State.Connections.autoAttack = nil
        end
    end
end

function Module.toggleAutoHeavy(value)
    Module.State.autoHeavyEnabled = value
    if value then
        if Module.State.autoHeavyConnection then
            Module.State.autoHeavyConnection:Disconnect()
        end
        Module.State.autoHeavyConnection = RunService.Heartbeat:Connect(function()
            if Module.State.autoHeavyEnabled then
                Module.executeAutoHeavy()
            end
        end)
        Module.State.Connections.autoHeavy = Module.State.autoHeavyConnection
    else
        if Module.State.autoHeavyConnection then
            Module.State.autoHeavyConnection:Disconnect()
            Module.State.autoHeavyConnection = nil
            Module.State.Connections.autoHeavy = nil
        end
    end
end

-- Anti-Void Functions
function Module.enableAntiVoid()
    if Module.State.antivoidloop then
        Module.State.antivoidloop:Disconnect()
        Module.State.antivoidloop = nil
    end
    Module.State.antivoidloop = RunService.Stepped:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if root and root.Position.Y <= Module.State.OrgDestroyHeight + 25 then
            root.Velocity = root.Velocity + Vector3.new(0, 250, 0)
        end
    end)
    Module.State.Connections.antivoid = Module.State.antivoidloop
    Module.State.antivoidEnabled = true
end

function Module.disableAntiVoid()
    if Module.State.antivoidloop then
        Module.State.antivoidloop:Disconnect()
        Module.State.antivoidloop = nil
        Module.State.Connections.antivoid = nil
    end
    Module.State.antivoidEnabled = false
end

function Module.fakeOut()
    local root = Module.getRoot(localPlayer.Character)
    if not root then return end
    local oldpos = root.CFrame
    if Module.State.antivoidloop then
        Module.disableAntiVoid()
        Module.State.antivoidWasEnabled = true
    end
    workspace.FallenPartsDestroyHeight = math.huge
    root.CFrame = CFrame.new(Vector3.new(0, Module.State.OrgDestroyHeight - 25, 0))
    task.wait(1)
    root.CFrame = oldpos
    workspace.FallenPartsDestroyHeight = Module.State.OrgDestroyHeight
    if Module.State.antivoidWasEnabled then
        Module.enableAntiVoid()
        Module.State.antivoidWasEnabled = false
    end
end

-- Spawn Functions
function Module.executeSpawn()
    local currentTime = tick()
    if currentTime - Module.State.lastSpawnTime < Module.State.SPAWN_COOLDOWN then
        return false
    end
    if Module.State.isSpawning then
        return false
    end
    Module.State.isSpawning = true
    Module.State.lastSpawnTime = currentTime
    pcall(function()
        game:GetService("ReplicatedStorage"):WaitForChild("shared/network/init@GlobalEvents", 9e9):WaitForChild("spawn", 9e9):FireServer(unpack(Module.State.SPAWN_ARGS))
    end)
    Module.State.isSpawning = false
    return true
end

function Module.getFullPath(obj)
    local path = obj.Name
    local parent = obj.Parent
    while parent and parent ~= game do
        path = parent.Name .. "." .. path
        parent = parent.Parent
    end
    return path
end

function Module.checkForNewAppGuis(currentGuis)
    local newAppGuis = {}
    for path, _ in pairs(currentGuis) do
        if not Module.State.lastVisibleGuis[path] and string.find(string.lower(path), "playergui%.app") ~= nil then
            table.insert(newAppGuis, path)
        end
    end
    return newAppGuis
end

function Module.scanForVisibleGuis()
    if not Module.State.AUTO_SPAWN_ENABLED then return end
    local currentGuis = {}
    local function scanGui(obj)
        if obj:IsA("GuiObject") and obj.Visible then
            local fullPath = Module.getFullPath(obj)
            currentGuis[fullPath] = true
        end
        for _, sub in ipairs(obj:GetChildren()) do
            scanGui(sub)
        end
    end
    pcall(function()
        scanGui(localPlayer:WaitForChild("PlayerGui"))
    end)
    local newAppGuis = Module.checkForNewAppGuis(currentGuis)
    if #newAppGuis > 0 then
        Module.executeSpawn()
    end
    Module.State.lastVisibleGuis = currentGuis
end

-- Terrain/Ground Detection
function Module.isAboveTerrain(position)
    local region = Region3.new(
        Vector3.new(position.X - 1, position.Y - 200, position.Z - 1),
        Vector3.new(position.X + 1, position.Y, position.Z + 1)
    )
    local terrainRegion = Workspace.Terrain:ReadVoxels(region, 4)
    local size = terrainRegion.Size
    for x = 1, size.X do
        for y = 1, size.Y do
            for z = 1, size.Z do
                if terrainRegion:get(x, y, z).Value > 0 then
                    return true
                end
            end
        end
    end
    return false
end

function Module.hasGroundBelow(position, maxDistance)
    maxDistance = maxDistance or 50
    if Module.isAboveTerrain(position) then
        return true
    end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {localPlayer.Character}
    local raycastResult = Workspace:Raycast(position, Vector3.new(0, -maxDistance, 0), raycastParams)
    return raycastResult ~= nil
end

-- Floating Functions
function Module.enableFloating()
    if Module.State.floatingEnabled or not localPlayer.Character then return end
    local pchar = localPlayer.Character
    local root = Module.getRoot(pchar)
    if not root then return end
    Module.State.floatingEnabled = true
    Module.State.floatPart = Instance.new('Part')
    Module.State.floatPart.Name = Module.State.floatName
    Module.State.floatPart.Parent = pchar
    Module.State.floatPart.Transparency = 1
    Module.State.floatPart.Size = Vector3.new(2, 0.2, 1.5)
    Module.State.floatPart.Anchored = true
    Module.State.floatPart.CFrame = root.CFrame * CFrame.new(0, -3.1, 0)
    local floatConnection
    floatConnection = RunService.Heartbeat:Connect(function()
        if Module.State.floatingEnabled and pchar:FindFirstChild(Module.State.floatName) and Module.getRoot(pchar) then
            Module.State.floatPart.CFrame = Module.getRoot(pchar).CFrame * CFrame.new(0, -3.1, 0)
        else
            if floatConnection then
                floatConnection:Disconnect()
            end
        end
    end)
end

function Module.disableFloating()
    if not Module.State.floatingEnabled then return end
    Module.State.floatingEnabled = false
    if Module.State.floatPart then
        Module.State.floatPart:Destroy()
        Module.State.floatPart = nil
    end
    local pchar = localPlayer.Character
    if pchar and pchar:FindFirstChild(Module.State.floatName) then
        pchar:FindFirstChild(Module.State.floatName):Destroy()
    end
end

function Module.startVoidDetection()
    if Module.State.voidDetectionLoop then
        Module.State.voidDetectionLoop:Disconnect()
    end
    Module.State.voidDetectionLoop = RunService.Heartbeat:Connect(function()
        local root = Module.getRoot(localPlayer.Character)
        if not root then return end
        local position = root.Position
        local hasGround = Module.hasGroundBelow(position, 100)
        if not hasGround then
            if Module.State.amberCollectionEnabled and not Module.State.amberPausedForVoid then
                Module.State.amberPausedForVoid = true
            end
            if not Module.State.floatingEnabled then
                Module.enableFloating()
            end
        else
            if Module.State.amberPausedForVoid then
                Module.State.amberPausedForVoid = false
            end
            if Module.State.floatingEnabled then
                Module.disableFloating()
            end
        end
    end)
end

function Module.stopVoidDetection()
    if Module.State.voidDetectionLoop then
        Module.State.voidDetectionLoop:Disconnect()
        Module.State.voidDetectionLoop = nil
    end
    Module.disableFloating()
    Module.State.amberPausedForVoid = false
end

-- Staff Watch Functions
function Module.getStaffRole(player)
    if game.CreatorType == Enum.CreatorType.Group then
        local groupId = game.CreatorId
        local success, role = pcall(function()
            return player:GetRoleInGroup(groupId)
        end)
        if success and role then
            local staffRoles = {"Owner", "Co-Owner", "Admin", "Administrator", "Moderator", "Mod", "Staff", "Developer", "Dev"}
            for _, staffRole in pairs(staffRoles) do
                if string.find(string.lower(role), string.lower(staffRole)) then
                    return {Staff = true, Role = role}
                end
            end
        end
    end
    return {Staff = false, Role = "Member"}
end

function Module.toggleStaffWatch(value)
    Module.State.staffwatchEnabled = value
    if value then
        if Module.State.staffwatchjoin then
            Module.State.staffwatchjoin:Disconnect()
        end
        if game.CreatorType == Enum.CreatorType.Group then
            Module.State.staffwatchjoin = Players.PlayerAdded:Connect(function(player)
                local result = Module.getStaffRole(player)
            end)
            for _, player in pairs(Players:GetPlayers()) do
                local result = Module.getStaffRole(player)
                if result.Staff then
                    print("@" .. player.Name .. " is a " .. result.Role)
                end
            end
        end
    else
        if Module.State.staffwatchjoin then
            Module.State.staffwatchjoin:Disconnect()
            Module.State.staffwatchjoin = nil
        end
    end
end

-- Anti-AFK Functions
function Module.enableAntiAfk()
    if Module.State.antiAfkEnabled then return end
    Module.State.antiAfkEnabled = true
    Module.State.antiAfkConnections.virtualUser = game:GetService("UserInputService").InputBegan:Connect(function() end)
    Module.State.antiAfkConnections.periodicInput = task.spawn(function()
        while Module.State.antiAfkEnabled do
            task.wait(300)
            VirtualUser:CaptureController()
            VirtualUser:ClickButton2(Vector2.new())
        end
    end)
    Module.State.antiAfkConnections.characterMovement = task.spawn(function()
        while Module.State.antiAfkEnabled do
            task.wait(600)
            local char = localPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local root = char.HumanoidRootPart
                local originalPos = root.CFrame
                root.CFrame = originalPos + Vector3.new(0.1, 0, 0)
                task.wait(0.1)
                root.CFrame = originalPos
            end
        end
    end)
    Module.State.antiAfkConnections.idleConnection = localPlayer.Idled:Connect(function()
        VirtualUser:Button2Down(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
        task.wait(1)
        VirtualUser:Button2Up(Vector2.new(0,0), workspace.CurrentCamera.CFrame)
    end)
end

function Module.disableAntiAfk()
    Module.State.antiAfkEnabled = false
    for name, connection in pairs(Module.State.antiAfkConnections) do
        if connection then
            if typeof(connection) == "RBXScriptConnection" then
                connection:Disconnect()
            else
                task.cancel(connection)
            end
        end
    end
    Module.State.antiAfkConnections = {}
end

-- Noclip Functions
function Module.noclip()
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.CanCollide then
            part.CanCollide = false
        end
    end
end

function Module.enableNoclip()
    if Module.State.noclipConnection then
        Module.State.noclipConnection:Disconnect()
        Module.State.noclipConnection = nil
    end
    Module.State.noclipConnection = RunService.Stepped:Connect(Module.noclip)
    Module.State.Connections.noclip = Module.State.noclipConnection
    Module.State.noclipEnabled = true
end

function Module.disableNoclip()
    if Module.State.noclipConnection then
        Module.State.noclipConnection:Disconnect()
        Module.State.noclipConnection = nil
        Module.State.Connections.noclip = nil
    end
    local character = localPlayer.Character
    if not character then return end
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    Module.State.noclipEnabled = false
end

-- Swimming Functions
function Module.startSwim()
    if not Module.State.swimming and localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        Module.State.oldgrav = workspace.Gravity
        workspace.Gravity = 0
        local swimDied = function()
            workspace.Gravity = Module.State.oldgrav
            Module.State.swimming = false
            Module.disableNoclip()
            Module.State.Connections.swimDied = nil
        end
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        Module.State.gravReset = Humanoid.Died:Connect(swimDied)
        Module.State.Connections.swimDied = Module.State.gravReset
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, false)
        end
        Humanoid:ChangeState(Enum.HumanoidStateType.Swimming)
        Module.State.swimbeat = RunService.Heartbeat:Connect(function()
            pcall(function()
                local hrp = localPlayer.Character.HumanoidRootPart
                local humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
                if Module.State.isSwimmingToDestination then
                    local currentPos = hrp.Position
                    local direction = (Module.State.swimDestination - currentPos).Unit
                    local distance = (Module.State.swimDestination - currentPos).Magnitude
                    if distance < 5 then
                        Module.State.isSwimmingToDestination = false
                        hrp.Velocity = Vector3.new(0, 0, 0)
                    else
                        hrp.Velocity = direction * Module.State.swimSpeed
                    end
                else
                    local moveVector = humanoid.MoveDirection
                    local camera = workspace.CurrentCamera
                    local cameraCFrame = camera.CFrame
                    local worldMoveVector = Vector3.new(0, 0, 0)
                    if moveVector.Magnitude > 0 then
                        local cameraRight = cameraCFrame.RightVector
                        local cameraForward = -cameraCFrame.LookVector
                        cameraRight = Vector3.new(cameraRight.X, 0, cameraRight.Z).Unit
                        cameraForward = Vector3.new(cameraForward.X, 0, cameraForward.Z).Unit
                        worldMoveVector = (cameraRight * moveVector.X + cameraForward * moveVector.Z)
                    end
                    local verticalMovement = 0
                    if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                        verticalMovement = 1
                    elseif UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
                        verticalMovement = -1
                    end
                    local finalMoveVector = Vector3.new(worldMoveVector.X, verticalMovement, worldMoveVector.Z)
                    if finalMoveVector.Magnitude > 0 then
                        hrp.Velocity = finalMoveVector.Unit * Module.State.swimSpeed
                    else
                        hrp.Velocity = hrp.Velocity * 0.9
                    end
                end
            end)
        end)
        Module.State.Connections.swimbeat = Module.State.swimbeat
        Module.enableNoclip()
        Module.State.swimming = true
        return true
    end
    return false
end

function Module.stopSwim()
    if localPlayer and localPlayer.Character and localPlayer.Character:FindFirstChildWhichIsA("Humanoid") then
        workspace.Gravity = Module.State.oldgrav
        Module.State.swimming = false
        Module.State.isSwimmingToDestination = false
        if Module.State.gravReset then
            Module.State.gravReset:Disconnect()
            Module.State.gravReset = nil
            Module.State.Connections.swimDied = nil
        end
        if Module.State.swimbeat then
            Module.State.swimbeat:Disconnect()
            Module.State.swimbeat = nil
            Module.State.Connections.swimbeat = nil
        end
        Module.disableNoclip()
        local Humanoid = localPlayer.Character:FindFirstChildWhichIsA("Humanoid")
        local enums = Enum.HumanoidStateType:GetEnumItems()
        table.remove(enums, table.find(enums, Enum.HumanoidStateType.None))
        for i, v in pairs(enums) do
            Humanoid:SetStateEnabled(v, true)
        end
    end
end

function Module.swimToDestination(targetPosition)
    local character = localPlayer.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then
        return
    end
    local hrp = character.HumanoidRootPart
    local currentPos = hrp.Position
    local skyPosition = Vector3.new(currentPos.X, currentPos.Y + 100, currentPos.Z)
    hrp.CFrame = CFrame.new(skyPosition)
    Module.State.isSwimmingToDestination = true
    Module.State.swimDestination = targetPosition
    if not Module.State.swimming then
        Module.startSwim()
    end
end

-- Movement Functions
function Module.moveTowardsTarget(targetPosition, stepSize, speed)
    local char = localPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return false end
    local root = char.HumanoidRootPart
    if not targetPosition then return false end
    local currentPos = root.Position
    local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
    local direction = (targetPosAbove - currentPos).Unit
    local distance = (targetPosAbove - currentPos).Magnitude
    if distance <= 8 then
        return true
    end
    local moveDistance = math.min(stepSize or 40, distance * 0.6)
    local newPos = currentPos + (direction * moveDistance)
    if newPos.Y > currentPos.Y then
        newPos = newPos + Vector3.new(0, 5, 0)
    end
    for _, part in pairs(char:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = false
        end
    end
    local tweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
    local tween = TweenService:Create(root, tweenInfo, {CFrame = CFrame.new(newPos, newPos + root.CFrame.LookVector)})
    tween.Completed:Connect(function()
        task.wait(0.05)
        for _, part in pairs(char:GetDescendants()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                part.CanCollide = true
            end
        end
    end)
    tween:Play()
    tween.Completed:Wait()
    return false
end

-- Walkspeed Functions
function Module.setWalkspeed(speed)
    if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
        local Char = localPlayer.Character
        local Human = Char:FindFirstChildWhichIsA("Humanoid")
        local function WalkSpeedChange()
            if Char and Human and Module.State.walkspeedEnabled then
                Human.WalkSpeed = speed
            end
        end
        WalkSpeedChange()
        Module.State.HumanModCons.wsLoop = (Module.State.HumanModCons.wsLoop and Module.State.HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
        Module.State.Connections.wsLoop = Module.State.HumanModCons.wsLoop
        Module.State.HumanModCons.wsCA = (Module.State.HumanModCons.wsCA and Module.State.HumanModCons.wsCA:Disconnect() and nil) or localPlayer.CharacterAdded:Connect(function(nChar)
            Char, Human = nChar, nChar:WaitForChild("Humanoid")
            character = nChar
            hrp = nChar:WaitForChild("HumanoidRootPart")
            WalkSpeedChange()
            Module.State.HumanModCons.wsLoop = (Module.State.HumanModCons.wsLoop and Module.State.HumanModCons.wsLoop:Disconnect() and nil) or Human:GetPropertyChangedSignal("WalkSpeed"):Connect(WalkSpeedChange)
            Module.State.Connections.wsLoop = Module.State.HumanModCons.wsLoop
        end)
        Module.State.Connections.wsCA = Module.State.HumanModCons.wsCA
    end
end

function Module.toggleWalkspeed(value)
    Module.State.walkspeedEnabled = value
    if value then
        Module.setWalkspeed(Module.State.customWalkspeed)
    else
        if Module.State.HumanModCons.wsLoop then
            Module.State.HumanModCons.wsLoop:Disconnect()
            Module.State.HumanModCons.wsLoop = nil
            Module.State.Connections.wsLoop = nil
        end
        if Module.State.HumanModCons.wsCA then
            Module.State.HumanModCons.wsCA:Disconnect()
            Module.State.HumanModCons.wsCA = nil
            Module.State.Connections.wsCA = nil
        end
        if localPlayer.Character and localPlayer.Character:FindFirstChild("Humanoid") then
            localPlayer.Character.Humanoid.WalkSpeed = 16
        end
    end
end

function Module.updateWalkspeed(value)
    Module.State.customWalkspeed = value
    if Module.State.walkspeedEnabled then
        Module.setWalkspeed(Module.State.customWalkspeed)
    end
end

-- ESP Functions
function Module.applyESP(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_ESP") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    local root = Module.getHumanoidRootPart(model)
    if not root then return end
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "NPC_ESP"
    billboard.Adornee = root
    billboard.Size = UDim2.new(0, 80, 0, 30)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.Text = model.Name
    label.TextColor3 = Color3.fromRGB(255, 0, 0)
    label.TextStrokeTransparency = 0
    label.TextScaled = true
    label.Font = Enum.Font.SourceSansBold
    label.Parent = billboard
    billboard.Parent = root
    Module.State.activeESPElements[model] = billboard
    local connection
    connection = humanoid.Died:Connect(function()
        billboard:Destroy()
        Module.State.activeESPElements[model] = nil
        if connection then
            Module.State.Connections["ESP_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Module.State.Connections["ESP_" .. tostring(model)] = connection
end

function Module.applyHighlight(model)
    if not model:IsA("Model") or not model:FindFirstChild("Humanoid") or not string.find(model.Name, "Goat") then return end
    if model:FindFirstChild("NPC_Highlight") then return end
    local humanoid = model:FindFirstChild("Humanoid")
    if not humanoid then return end
    local highlight = Instance.new("Highlight")
    highlight.Name = "NPC_Highlight"
    highlight.Adornee = model
    highlight.FillColor = Color3.fromRGB(100, 150, 255)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.FillTransparency = 0.7
    highlight.OutlineTransparency = 0
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.Parent = model
    Module.State.activeHighlights[model] = highlight
    local connection
    connection = humanoid.Died:Connect(function()
        highlight:Destroy()
        Module.State.activeHighlights[model] = nil
        if connection then
            Module.State.Connections["Highlight_" .. tostring(model)] = nil
            connection:Disconnect()
        end
    end)
    Module.State.Connections["Highlight_" .. tostring(model)] = connection
end

function Module.toggleESP(value)
    Module.State.espEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyESP(model)
        end
    else
        for model, billboard in pairs(Module.State.activeESPElements) do
            if billboard and billboard.Parent then
                billboard:Destroy()
            end
            if Module.State.Connections["ESP_" .. tostring(model)] then
                Module.State.Connections["ESP_" .. tostring(model)]:Disconnect()
                Module.State.Connections["ESP_" .. tostring(model)] = nil
            end
        end
        Module.State.activeESPElements = {}
    end
end

function Module.toggleHighlight(value)
    Module.State.highlightEnabled = value
    if value then
        for _, model in pairs(folder:GetChildren()) do
            Module.applyHighlight(model)
        end
    else
        for model, highlight in pairs(Module.State.activeHighlights) do
            if highlight and highlight.Parent then
                highlight:Destroy()
            end
            if Module.State.Connections["Highlight_" .. tostring(model)] then
                Module.State.Connections["Highlight_" .. tostring(model)]:Disconnect()
                Module.State.Connections["Highlight_" .. tostring(model)] = nil
            end
        end
        Module.State.activeHighlights = {}
    end
end

-- Player Teleport Functions
function Module.getValidPlayers()
    local players = Players:GetPlayers()
    local validPlayers = {}
    for _, player in pairs(players) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and 
           player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local isMoving = Module.isPlayerMoving(player)
            if (isMoving and Module.State.targetMovingPlayers) or (not isMoving and Module.State.targetStillPlayers) then
                table.insert(validPlayers, player)
            end
        end
    end
    return validPlayers
end

function Module.getNextTarget()
    local validPlayers = Module.getValidPlayers()
    if #validPlayers == 0 then
        return nil
    end
    Module.State.playerIndex = ((Module.State.playerIndex - 1) % #validPlayers) + 1
    return validPlayers[Module.State.playerIndex]
end

function Module.anchorToPlayer(targetPlayer)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetPlayer.Character.HumanoidRootPart
    local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    local targetLookVector = targetRoot.CFrame.LookVector
    if targetHumanoid and targetHumanoid.MoveDirection.Magnitude > 0.1 then
        local moveDirection = targetHumanoid.MoveDirection
        targetLookVector = Vector3.new(moveDirection.X, 0, moveDirection.Z).Unit
    end
    local behindPosition = targetRoot.Position - (targetLookVector * Module.State.behindDistance)
    behindPosition = Vector3.new(behindPosition.X, targetRoot.Position.Y, behindPosition.Z)
    local newCFrame = CFrame.lookAt(behindPosition, targetRoot.Position)
    localPlayer.Character.HumanoidRootPart.CFrame = newCFrame
    localPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    localPlayer.Character.HumanoidRootPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.teleportLoop()
    if not Module.State.teleporting then return end
    if not Module.State.currentTarget or Module.isPlayerDead(Module.State.currentTarget) then
        Module.State.currentTarget = Module.getNextTarget()
        if Module.State.currentTarget then
            Module.anchorToPlayer(Module.State.currentTarget)
        else
            task.wait(1)
            return
        end
    end
    if localPlayer.Character and Module.State.currentTarget.Character then
        local myPosition = localPlayer.Character.HumanoidRootPart.Position
        local targetPosition = Module.State.currentTarget.Character.HumanoidRootPart.Position
        local targetLookVector = Module.State.currentTarget.Character.HumanoidRootPart.CFrame.LookVector
        local intendedPosition = targetPosition - (targetLookVector * Module.State.behindDistance)
        local distanceFromIntended = (myPosition - intendedPosition).Magnitude
        if distanceFromIntended > 2 then
            Module.anchorToPlayer(Module.State.currentTarget)
        end
    end
end

-- NPC Teleport Functions
function Module.getClosestNPC()
    local closest = nil
    local shortestDist = math.huge
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortestDist then
                shortestDist = dist
                closest = npc
            end
        end
    end
    return closest
end

function Module.anchorToNPC(targetNPC)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetNPC:FindFirstChild("HumanoidRootPart")
    if not targetRoot then
        return false
    end
    local dir = -(targetRoot.CFrame.LookVector) * Module.State.npcBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.npcTeleportLoop()
    if not Module.State.npcTeleportEnabled then return end
    if not Module.State.currentNPCTarget or not Module.State.currentNPCTarget:IsDescendantOf(workspace) or Module.State.currentNPCTarget.Humanoid.Health <= 0 then
        Module.State.currentNPCTarget = Module.getClosestNPC()
        if not Module.State.currentNPCTarget then
            return
        end
    end
    if hrp and Module.State.currentNPCTarget.HumanoidRootPart then
        Module.anchorToNPC(Module.State.currentNPCTarget)
    end
end

function Module.toggleNPCTeleport(value)
    Module.State.npcTeleportEnabled = value
    if value then
        Module.State.currentNPCTarget = Module.getClosestNPC()
        if Module.State.currentNPCTarget then
            Module.anchorToNPC(Module.State.currentNPCTarget)
        end
        Module.State.npcTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.npcTeleportLoop()
        end)
        Module.State.Connections.npcTeleport = Module.State.npcTeleportConnection
    else
        Module.State.currentNPCTarget = nil
        if Module.State.npcTeleportConnection then
            Module.State.npcTeleportConnection:Disconnect()
            Module.State.npcTeleportConnection = nil
            Module.State.Connections.npcTeleport = nil
        end
    end
end

function Module.switchToNextNPC()
    local allNPCs = {}
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "Goat" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            table.insert(allNPCs, npc)
        end
    end
    if #allNPCs == 0 then
        return nil
    elseif #allNPCs == 1 then
        return allNPCs[1]
    else
        for _, npc in pairs(allNPCs) do
            if npc ~= Module.State.currentNPCTarget then
                return npc
            end
        end
        return allNPCs[1]
    end
end

-- Boss Teleport Functions
function Module.getClosestBoss()
    local closest = nil
    local shortestDist = math.huge
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "D-Rex Boss" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            local dist = (npc.HumanoidRootPart.Position - hrp.Position).Magnitude
            if dist < shortestDist then
                shortestDist = dist
                closest = npc
            end
        end
    end
    return closest
end

function Module.anchorToBoss(targetBoss)
    if not localPlayer.Character or not localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    local targetRoot = targetBoss:FindFirstChild("HumanoidRootPart")
    if not targetRoot then
        return false
    end
    local dir = -(targetRoot.CFrame.LookVector) * Module.State.bossBehindDistance
    hrp.CFrame = CFrame.new(targetRoot.Position + dir, targetRoot.Position)
    hrp.Velocity = Vector3.new(0, 0, 0)
    hrp.RotVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
    hrp.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
    return true
end

function Module.bossTeleportLoop()
    if not Module.State.bossTeleportEnabled then return end
    if not Module.State.currentBossTarget or not Module.State.currentBossTarget:IsDescendantOf(workspace) or Module.State.currentBossTarget.Humanoid.Health <= 0 then
        Module.State.currentBossTarget = Module.getClosestBoss()
        if not Module.State.currentBossTarget then
            return
        end
    end
    if hrp and Module.State.currentBossTarget.HumanoidRootPart then
        Module.anchorToBoss(Module.State.currentBossTarget)
    end
end

function Module.toggleBossTeleport(value)
    Module.State.bossTeleportEnabled = value
    if value then
        Module.State.currentBossTarget = Module.getClosestBoss()
        if Module.State.currentBossTarget then
            Module.anchorToBoss(Module.State.currentBossTarget)
        end
        Module.State.bossTeleportConnection = RunService.Heartbeat:Connect(function()
            Module.bossTeleportLoop()
        end)
        Module.State.Connections.bossTeleport = Module.State.bossTeleportConnection
    else
        Module.State.currentBossTarget = nil
        if Module.State.bossTeleportConnection then
            Module.State.bossTeleportConnection:Disconnect()
            Module.State.bossTeleportConnection = nil
            Module.State.Connections.bossTeleport = nil
        end
    end
end

function Module.switchToNextBoss()
    local allBosses = {}
    for _, npc in pairs(folder:GetChildren()) do
        if npc:IsA("Model") and npc.Name == "D-Rex Boss" and npc:FindFirstChild("Humanoid") and npc:FindFirstChild("HumanoidRootPart") and npc.Humanoid.Health > 0 then
            table.insert(allBosses, npc)
        end
    end
    if #allBosses == 0 then
        return nil
    elseif #allBosses == 1 then
        return allBosses[1]
    else
        for _, npc in pairs(allBosses) do
            if npc ~= Module.State.currentBossTarget then
                return npc
            end
        end
        return allBosses[1]
    end
end

-- Amber Collection Helper Functions
function Module.deepSearchProximityPrompts(obj, path)
    local prompts = {}
    path = path or obj.Name
    if obj:IsA("ProximityPrompt") then
        table.insert(prompts, {prompt = obj, path = path, parent = obj.Parent})
        return prompts
    end
    for _, child in pairs(obj:GetChildren()) do
        local childPath = path .. "." .. child.Name
        local childPrompts = Module.deepSearchProximityPrompts(child, childPath)
        for _, promptData in pairs(childPrompts) do
            table.insert(prompts, promptData)
        end
    end
    return prompts
end

function Module.getBestPosition(obj)
    local function findPartPosition(searchObj)
        if searchObj:IsA("BasePart") then
            return searchObj.Position
        elseif searchObj:IsA("Model") and searchObj.PrimaryPart then
            return searchObj.PrimaryPart.Position
        else
            for _, child in pairs(searchObj:GetChildren()) do
                if child:IsA("BasePart") then
                    return child.Position
                end
            end
        end
        return nil
    end
    local pos = findPartPosition(obj)
    if pos then return pos end
    local current = obj.Parent
    while current and current ~= Workspace do
        pos = findPartPosition(current)
        if pos then return pos end
        current = current.Parent
    end
    return nil
end

function Module.getAllAmberPrompts()
    local itemSpawn = Workspace:FindFirstChild("ItemSpawn")
    if not itemSpawn then
        return {}
    end
    local amber = itemSpawn:FindFirstChild("Amber")
    if not amber then
        return {}
    end
    local allPrompts = {}
    for _, child in pairs(amber:GetChildren()) do
        if child.Name == "AmberSpawn" then
            local prompts = Module.deepSearchProximityPrompts(child)
            for _, promptData in pairs(prompts) do
                local promptId = tostring(promptData.prompt)
                if not Module.State.processedPrompts[promptId] and promptData.prompt.Parent and promptData.prompt.Enabled then
                    table.insert(allPrompts, promptData)
                end
            end
        end
    end
    return allPrompts
end

-- Amber Collection Methods
function Module.fireProximityPromptSwim(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        Module.State.processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        Module.State.processedPrompts[promptId] = true
        return false
    end
    if not Module.State.swimming then
        Module.startSwim()
        task.wait(0.2)
    end
    Module.swimToDestination(targetPosition)
    local timeoutCounter = 0
    local maxTimeout = 50
    while Module.State.isSwimmingToDestination and timeoutCounter < maxTimeout do
        task.wait(0.1)
        timeoutCounter = timeoutCounter + 1
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
    end
    if hrp and prompt.Parent and prompt.Enabled then
        local distance = (hrp.Position - targetPosition).Magnitude
        if distance < 20 then
            local success = false
            pcall(function()
                fireproximityprompt(prompt, 0, true)
                success = true
            end)
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt)
                    success = true
                end)
            end
            task.wait(0.05)
            if prompt.Parent and prompt.Enabled and not success then
                pcall(function()
                    fireproximityprompt(prompt, prompt.HoldDuration or 0)
                    success = true
                end)
            end
        end
    end
    Module.State.processedPrompts[promptId] = true
    task.wait(0.1)
    return true
end

function Module.fireProximityPromptTween(promptData)
    if not fireproximityprompt then
        return false
    end
    local prompt = promptData.prompt
    local promptId = tostring(prompt)
    if not prompt.Parent or not prompt.Enabled then
        Module.State.processedPrompts[promptId] = true
        return false
    end
    local targetPosition = Module.getBestPosition(prompt)
    if not targetPosition then
        Module.State.processedPrompts[promptId] = true
        return false
    end
    Module.State.amberAttemptStartTime = tick()
    local maxAttempts = 6
    local attempts = 0
    while attempts < maxAttempts and Module.State.amberCollectionEnabled do
        attempts = attempts + 1
        if not prompt.Parent or not prompt.Enabled then
            Module.State.processedPrompts[promptId] = true
            return false
        end
        if tick() - Module.State.amberAttemptStartTime > Module.State.amberAttemptTimeout then
            Module.State.processedPrompts[promptId] = true
            return false
        end
        for _, part in pairs(localPlayer.Character:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
        local isCloseEnough = Module.moveTowardsTarget(targetPosition, 50, 5)
        task.wait(0.15)
        if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hrp = localPlayer.Character.HumanoidRootPart
        end
        if hrp and prompt.Parent and prompt.Enabled then
            local targetPosAbove = Vector3.new(targetPosition.X, targetPosition.Y + 2, targetPosition.Z)
            local distance = (hrp.Position - targetPosAbove).Magnitude
            if distance < 30 then
                local success = false
                pcall(function()
                    fireproximityprompt(prompt, 0, true)
                    success = true
                end)
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt)
                        success = true
                    end)
                end
                task.wait(0.02)
                if prompt.Parent and prompt.Enabled and not success then
                    pcall(function()
                        fireproximityprompt(prompt, prompt.HoldDuration or 0)
                        success = true
                    end)
                end
                if success then
                    Module.State.lastCollectionTime = tick()
                end
                break
            end
        end
    end
    for _, part in pairs(localPlayer.Character:GetDescendants()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.CanCollide = true
        end
    end
    Module.State.processedPrompts[promptId] = true
    task.wait(0.05)
    return true
end

function Module.amberCollectionLoopSwim()
    if not Module.State.amberCollectionEnabled or Module.State.isCollecting then 
        return 
    end
    Module.State.isCollecting = true
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        Module.State.currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptSwim(Module.State.currentAmberTarget)
    else
        Module.State.processedPrompts = {}
        Module.State.currentAmberTarget = nil
        Module.stopSwim()
        task.wait(1)
    end
    Module.State.isCollecting = false
end

function Module.amberCollectionLoopTween()
    if not Module.State.amberCollectionEnabled then 
        return 
    end
    if Module.State.amberPausedForVoid then
        return
    end
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        hrp = localPlayer.Character.HumanoidRootPart
        local currentPos = hrp.Position
        local distanceMoved = (currentPos - Module.State.lastPlayerPosition).Magnitude
        if distanceMoved < 0.5 then
            Module.State.stuckCheckCounter = Module.State.stuckCheckCounter + 1
        else
            Module.State.stuckCheckCounter = 0
        end
        Module.State.lastPlayerPosition = currentPos
        if Module.State.stuckCheckCounter > Module.State.stuckThreshold and not Module.State.v2SwitchedToV1 then
            Module.State.v2SwitchedToV1 = true
            return
        end
    end
    local availablePrompts = Module.getAllAmberPrompts()
    if #availablePrompts > 0 then
        if hrp then
            table.sort(availablePrompts, function(a, b)
                local posA = Module.getBestPosition(a.prompt)
                local posB = Module.getBestPosition(b.prompt)
                if posA and posB then
                    local distA = (hrp.Position - posA).Magnitude
                    local distB = (hrp.Position - posB).Magnitude
                    return distA < distB
                end
                return false
            end)
        end
        Module.State.currentAmberTarget = availablePrompts[1]
        Module.fireProximityPromptTween(Module.State.currentAmberTarget)
    else
        Module.State.currentAmberTarget = nil
        Module.State.processedPrompts = {}
    end
end

function Module.toggleAmberCollectionSwim(value)
    Module.State.amberCollectionEnabled = value
    if value then
        Module.State.processedPrompts = {}
        Module.State.currentAmberTarget = nil
        Module.State.amberCollectionCoroutine = task.spawn(function()
            while Module.State.amberCollectionEnabled do
                pcall(function()
                    Module.amberCollectionLoopSwim()
                end)
                task.wait(0.3)
            end
        end)
    else
        Module.State.amberCollectionEnabled = false
        Module.State.currentAmberTarget = nil
        Module.State.isCollecting = false
        Module.stopSwim()
        if Module.State.amberCollectionCoroutine then
            task.cancel(Module.State.amberCollectionCoroutine)
            Module.State.amberCollectionCoroutine = nil
        end
    end
end

function Module.toggleAmberCollection(value)
    Module.State.amberCollectionEnabled = value
    if value then
        Module.State.lastCollectionTime = tick()
        Module.enableAntiVoid()
        Module.startVoidDetection()
        Module.State.processedPrompts = {}
        Module.State.currentAmberTarget = nil
        Module.State.v2SwitchedToV1 = false
        Module.State.stuckCheckCounter = 0
        Module.State.lastPlayerPosition = Vector3.new(0, 0, 0)
        Module.State.amberCollectionCoroutine = task.spawn(function()
            while Module.State.amberCollectionEnabled do
                pcall(function()
                    if Module.State.v2SwitchedToV1 then
                        Module.amberCollectionLoopSwim()
                        if not Module.State.swimming then
                            Module.State.v2SwitchedToV1 = false
                            Module.State.stuckCheckCounter = 0
                        end
                    else
                        Module.amberCollectionLoopTween()
                    end
                end)
                task.wait(0.05)
            end
        end)
    else
        Module.State.amberCollectionEnabled = false
        Module.State.currentAmberTarget = nil
        Module.State.amberPausedForVoid = false
        Module.State.v2SwitchedToV1 = false
        Module.State.stuckCheckCounter = 0
        Module.stopVoidDetection()
        Module.disableAntiVoid()
        if Module.State.amberCollectionCoroutine then
            task.cancel(Module.State.amberCollectionCoroutine)
            Module.State.amberCollectionCoroutine = nil
        end
    end
end

-- Cleanup Function
function Module.cleanup()
    for key, connection in pairs(Module.State.Connections) do
        if connection then
            connection:Disconnect()
            Module.State.Connections[key] = nil
        end
    end
    Module.stopSwim()
    Module.toggleWalkspeed(false)
    Module.toggleNPCTeleport(false)
    Module.toggleAmberCollection(false)
    Module.toggleAmberCollectionSwim(false)
    Module.toggleESP(false)
    Module.toggleHighlight(false)
    Module.State.teleporting = false
    Module.State.currentTarget = nil
    Module.disableAntiVoid()
    Module.toggleBossTeleport(false)
    Module.stopVoidDetection()
    Module.toggleStaffWatch(false)
    Module.disableAntiAfk()
    Module.disableNoclip()
    Module.State.AUTO_SPAWN_ENABLED = false
    for key, connection in pairs(Module.State.knockbackInputConnections) do
        if connection then
            connection:Disconnect()
        end
    end
    Module.State.knockbackInputConnections = {}
end

-- Initialize Event Connections
function Module.initConnections()
    Module.State.Connections.childAdded = folder.ChildAdded:Connect(function(model)
        task.wait(0.2)
        if Module.State.espEnabled then
            Module.applyESP(model)
        end
        if Module.State.highlightEnabled then
            Module.applyHighlight(model)
        end
    end)

    Module.State.Connections.charAdded = localPlayer.CharacterAdded:Connect(function(char)
        character = char
        hrp = char:WaitForChild("HumanoidRootPart")
        if Module.State.walkspeedEnabled then
            task.wait(1)
            Module.setWalkspeed(Module.State.customWalkspeed)
        end
        if Module.State.swimming then
            task.wait(1)
            Module.startSwim()
        end
    end)

    Module.State.Connections.charRemoving = localPlayer.CharacterRemoving:Connect(function()
        Module.stopSwim()
    end)

    Module.State.Connections.playerRemoving = Players.PlayerRemoving:Connect(function(player)
        if Module.State.teleporting and Module.State.currentTarget == player then
            Module.State.currentTarget = Module.getNextTarget()
            if Module.State.currentTarget then
                Module.anchorToPlayer(Module.State.currentTarget)
            end
        end
    end)

    Module.State.Connections.teleportLoop = RunService.Heartbeat:Connect(function()
        if Module.State.teleporting and Module.State.currentTarget and Module.State.currentTarget.Character and Module.State.currentTarget.Character:FindFirstChild("HumanoidRootPart") then
            Module.teleportLoop()
        end
    end)

    task.spawn(function()
        task.wait(2)
        Module.scanForVisibleGuis()
        while true do
            task.wait(1)
            pcall(Module.scanForVisibleGuis)
        end
    end)
end

return Module
