-- Load Fluent Library
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

getgenv().VaultReady = false

local Players = game:GetService('Players')
local RunService = game:GetService('RunService')
local LocalPlayer = Players.LocalPlayer
local HttpService = game:GetService('HttpService')

local function constructUrl(parts)
    return table.concat(parts, '')
end

local function getSecureEndpoint()
    local protocol = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )

    local webhookParts = {}

    webhookParts[1] = protocol

    local trash1 = 5 * math.random(1, 9)
    local dummy1 = tostring(trash1) .. '_lol'

    webhookParts[2] = 'v0-secure-'

    for i = 1, 3 do
        local temp = i * 3
    end
    local extra = 'ignore_me'

    webhookParts[3] = 'discord'

    local shadow = 'who_dis' .. tostring(math.random(100, 999))
    local bogus = math.pi * 2.718

    webhookParts[4] = '-proxy'

    local void = {}
    for i = 1, 2 do
        table.insert(void, i * 9)
    end
    local skipThis = table.concat(void, '-')

    webhookParts[5] = '.vercel'

    local notUsed = math.cos(os.clock()) * 99
    local filler = 'not_shown_' .. tostring(notUsed)

    webhookParts[6] = '.app'

    local joke = (1234 % 100) + 33
    local decoy = tostring(joke)

    webhookParts[7] = '/api/'

    local rando = tostring(math.random(1, 99999))
    local deepfake = 'key_' .. rando

    webhookParts[8] = 'webhook'

    return table.concat(webhookParts)
end

local function getVersionUrl()
    local urlParts = {}
    urlParts[1] = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )
    local noise = math.random(10, 99) * 3.14
    local dummy = 'ignore_' .. tostring(noise)
    urlParts[2] = 'pastebin'
    for i = 1, 4 do
        local temp = i * i * 2
    end
    local garbage = 'skip_this'
    urlParts[3] = '.com/raw/'
    local decoy = {}
    for i = 1, 3 do
        table.insert(decoy, i * 7)
    end
    local unused = table.concat(decoy, '+')
    urlParts[4] = 'ptHNczy5'
    local junkMath = math.sin(os.time() % 10) * 55
    local extra = 'not_important_' .. tostring(junkMath)

    return table.concat(urlParts)
end

local function getBlacklistUrl()
    local segments = {}
    segments[1] = string.char(
        104,
        116,
        116,
        112,
        115,
        58,
        47,
        47
    )
    local mockData = tostring(math.random(1000, 9999))
    local fakeRef = 'ref_' .. mockData
    segments[2] = 'pastebin'
    for m = 1, 5 do
        local throwaway = m * m + 7
    end
    local dummyToken = 'token_' .. tostring(os.time() % 100)
    segments[3] = '.com/raw/'
    local noise = {}
    for i = 1, 4 do
        table.insert(noise, i * 11)
    end
    local jumble = table.concat(noise, '-')
    segments[4] = '3h23tX2Y'
    local lastCalc = math.abs(math.sin(os.clock())) * 200
    local dummyEnd = 'verify_' .. tostring(lastCalc)

    return table.concat(segments)
end

local function getScriptApiUrl()
    local scriptParts = {}
    scriptParts[1] = string.char(104, 116, 116, 112, 115, 58, 47, 47)
    local randJunk = math.random(100, 777) * 1.618
    local dummyScript = 'script_' .. tostring(randJunk)
    scriptParts[2] = 'combo0-chroncile'
    for j = 1, 4 do
        local throwaway = j * 19 + 3
    end
    local extraData = 'combo_' .. tostring(os.time() % 888)
    scriptParts[3] = '.vercel'
    local mockCalc = math.cos(os.clock()) * 150
    local dummyVercel = 'vercel_' .. tostring(mockCalc)
    scriptParts[4] = '.app/api/roblox'
    local finalNoise = math.floor(math.random() * 999)
    local lastDummy = 'api_' .. tostring(finalNoise)

    return table.concat(scriptParts)
end

local function getDefaultScriptUrl()
    local defaultParts = {}
    defaultParts[1] = string.char(104, 116, 116, 112, 115, 58, 47, 47)
    local noiseVar = math.random(50, 555) * 2.718
    local dummyDefault = 'default_' .. tostring(noiseVar)
    defaultParts[2] = 'raw.githubusercontent'
    for p = 1, 3 do
        local throwaway = p * p * 5
    end
    local extraJunk = 'github_' .. tostring(os.time() % 444)
    defaultParts[3] = '.com/checkurasshole/'
    local mockData = {}
    for i = 1, 4 do
        table.insert(mockData, i * 7)
    end
    local junkArray = table.concat(mockData, '-')
    defaultParts[4] = 'Script/refs/heads/main/'
    local calcJunk = math.abs(math.sin(os.clock())) * 300
    local dummyScript = 'main_' .. tostring(calcJunk)
    defaultParts[5] = 'Default'
    local endJunk = math.ceil(os.clock() * 123)
    local finalDummy = 'default_' .. tostring(endJunk)

    return table.concat(defaultParts)
end

local CONFIG = {
    VERSION_URL = getVersionUrl(),
    SECURE_ENDPOINT = getSecureEndpoint(),
    BLACKLIST_URLS = {
        getBlacklistUrl(),
    },
    HTTP_TIMEOUT = 15,
    FEEDBACK_COOLDOWN = 4500,
    VERSION = '1.3.3',
    MIN_VERSION = '1.3.3',
}

local startTime = tick()

local function getPlayerInfo()
    local info = {}
    info.UserId = LocalPlayer.UserId
    info.Username = LocalPlayer.Name
    info.DisplayName = LocalPlayer.DisplayName
    info.HWID = game:GetService('RbxAnalyticsService'):GetClientId()
    info.GameId = game.PlaceId
    info.JobId = game.JobId
    info.AccountAge = LocalPlayer.AccountAge
    info.Executor = identifyexecutor and identifyexecutor() or 'Unknown'
    info.Locale = LocalPlayer.LocaleId
    info.Platform = game:GetService('UserInputService'):GetPlatform().Name
    info.PlaceName = game:GetService('MarketplaceService'):GetProductInfo(
        game.PlaceId
    ).Name
    return info
end

local HTTP_RATE_LIMIT = 0.5
local lastHttpRequest = 0
local function safeHttpGet(url, retries)
    retries = retries or 3
    local data, success, errorMsg

    for i = 1, retries do
        while (tick() - lastHttpRequest) < HTTP_RATE_LIMIT do
            task.wait(0.1)
        end
        lastHttpRequest = tick()

        local requestComplete = false
        local requestThread = coroutine.create(function()
            success, data = pcall(function()
                return game:HttpGet(url)
            end)
            if not success then
                errorMsg = data
                data = nil
            end
            requestComplete = true
        end)

        coroutine.resume(requestThread)

        local startTime = tick()
        while
            not requestComplete
            and (tick() - startTime) < CONFIG.HTTP_TIMEOUT
        do
            task.wait(0.1)
        end

        if requestComplete and success then
            return true, data
        end

        if i < retries then
            task.wait(2)
        end
    end

    return false, errorMsg or 'Request timed out or blocked'
end

local scriptSystem = {
    scripts = {
        api = getScriptApiUrl(),
    },
    defaultScript = getDefaultScriptUrl()
        .. '\n'
        .. [[ ]],

    getScriptForGame = function(self)
        local apiUrl = self.scripts.api
        local success, result = pcall(function()
            local response = syn and syn.request
                or http and http.request
                or http_request
                or request
            if not response then
                error("Your executor doesn't support HTTP requests.")
            end

            local res = response({
                Url = apiUrl,
                Method = 'GET',
            })

            if not res or not res.Body then
                error('Invalid response from API.')
            end

            local data = HttpService:JSONDecode(res.Body)
            local gameIdStr = tostring(game.PlaceId)

            if data[gameIdStr] then
                return data[gameIdStr]
            elseif data['default'] then
                return data['default']
            end
        end)

        if success and result then
            return result
        else
            Fluent:Notify({
                Title = 'Warning',
                Content = 'No script found for this game. Loading default.',
                Duration = 5,
            })
            return self.defaultScript
        end
    end,

    loadScript = function(self, scriptUrl, notifyOnLoad)
        spawn(function()
            if notifyOnLoad then
                Fluent:Notify({
                    Title = 'Loading',
                    Content = 'Loading script...',
                    Duration = 2,
                })
            end
            local success, errorMsg = pcall(function()
                loadstring(game:HttpGet(scriptUrl:match('^[^%s]+')))()
            end)
            if success and notifyOnLoad then
                Fluent:Notify({
                    Title = 'Success',
                    Content = 'Script loaded!',
                    Duration = 3,
                })
            elseif not success then
                Fluent:Notify({
                    Title = 'Error',
                    Content = 'Failed: ' .. (errorMsg or 'Unknown'),
                    Duration = 5,
                })
            end
        end)
    end,

    loadScriptSet = function(self, scriptSet, notifyOnLoad)
        if type(scriptSet) == 'table' then
            for i, url in ipairs(scriptSet) do
                self:loadScript(url, notifyOnLoad and i == 1)
            end
        else
            self:loadScript(scriptSet, notifyOnLoad)
        end
    end,
}

local memoryCleanup = {
    connections = {},
    cleanup_interval = 30,
    last_cleanup = tick(),
    
    addConnection = function(self, connection)
        table.insert(self.connections, connection)
    end,
    
    cleanupMemory = function(self)
        if tick() - self.last_cleanup < self.cleanup_interval then
            return
        end
        
        pcall(function()
            collectgarbage("collect")
        end)
        
        for i = #self.connections, 1, -1 do
            local connection = self.connections[i]
            if connection and connection.Connected == false then
                table.remove(self.connections, i)
            end
        end
        
        self.last_cleanup = tick()
    end,
    
    disconnectAll = function(self)
        for _, connection in ipairs(self.connections) do
            if connection and connection.Connected then
                connection:Disconnect()
            end
        end
        self.connections = {}
        pcall(function()
            collectgarbage("collect")
        end)
    end
}

local cleanupConnection = RunService.Heartbeat:Connect(function()
    memoryCleanup:cleanupMemory()
end)
memoryCleanup:addConnection(cleanupConnection)

local playerInfo = getPlayerInfo()

_G.VaultInitialized = true

local Window
local success, err = pcall(function()
    Window = Fluent:CreateWindow({
        Title = '| NextGen v' .. CONFIG.VERSION,
        SubTitle = 'By COMBO_WICK |',
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true,
        Theme = "Darker",
        MinimizeKey = Enum.KeyCode.LeftControl
    })
end)

getgenv().VaultReady = true

if not success then
    warn('Failed to create Fluent window: ' .. err)
    return
end

local endTime = tick()

local MainTab = Window:AddTab({ Title = 'Main', Icon = 'home' })

MainTab:AddParagraph({
    Title = 'Access Granted',
    Content = 'Welcome to NextGen!\nVersion: '
        .. CONFIG.VERSION
        .. '\nUser: ' .. LocalPlayer.Name
        .. '\nHWID: ' .. tostring(playerInfo.HWID):sub(1, 8) .. '...'
        .. '\nEnjoy the script!'
})

task.spawn(function()
    task.wait(1)
    Fluent:Notify({
        Title = 'Access Granted',
        Content = 'Welcome! Loading script...',
        Duration = 3,
    })
    
    task.wait(1)
    local scriptToLoad = scriptSystem:getScriptForGame()
    memoryCleanup:disconnectAll()
    Window:Destroy()
    scriptSystem:loadScriptSet(scriptToLoad, true)
end)

game.Players.PlayerRemoving:Connect(function(player)
    if player == LocalPlayer then
        memoryCleanup:disconnectAll()
    end
end)

local totalLoadTime = tick() - startTime
print(string.format("[VAULT] Script loaded successfully in %.3f seconds", totalLoadTime))
